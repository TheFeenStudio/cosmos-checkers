{"version":3,"file":"index.production.js","sources":["../../../query-core/build/lib/subscribable.mjs","../../../query-core/build/lib/utils.mjs","../../../query-core/build/lib/focusManager.mjs","../../../query-core/build/lib/onlineManager.mjs","../../../query-core/build/lib/retryer.mjs","../../../query-core/build/lib/logger.mjs","../../../query-core/build/lib/notifyManager.mjs","../../../query-core/build/lib/removable.mjs","../../../query-core/build/lib/query.mjs","../../../query-core/build/lib/queryCache.mjs","../../../query-core/build/lib/mutation.mjs","../../../query-core/build/lib/mutationCache.mjs","../../../query-core/build/lib/infiniteQueryBehavior.mjs","../../../query-core/build/lib/queryObserver.mjs","../../../query-core/build/lib/queriesObserver.mjs","../../../query-core/build/lib/infiniteQueryObserver.mjs","../../../query-core/build/lib/mutationObserver.mjs","../../../query-core/build/lib/hydration.mjs","../../src/utils.ts","../../src/useQueryClient.ts","../../src/queryCache.ts","../../src/mutationCache.ts","../../src/queryClient.ts","../../../query-core/build/lib/queryClient.mjs","../../src/vueQueryPlugin.ts","../../src/useBaseQuery.ts","../../src/useIsFetching.ts","../../src/useIsMutating.ts","../../src/useInfiniteQuery.ts","../../src/useMutation.ts","../../src/useQueries.ts","../../src/useQuery.ts"],"sourcesContent":["class Subscribable {\n  constructor() {\n    this.listeners = [];\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  subscribe(listener) {\n    this.listeners.push(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners = this.listeners.filter(x => x !== listener);\n      this.onUnsubscribe();\n    };\n  }\n\n  hasListeners() {\n    return this.listeners.length > 0;\n  }\n\n  onSubscribe() {// Do nothing\n  }\n\n  onUnsubscribe() {// Do nothing\n  }\n\n}\n\nexport { Subscribable };\n//# sourceMappingURL=subscribable.mjs.map\n","// TYPES\n// UTILS\nconst isServer = typeof window === 'undefined';\nfunction noop() {\n  return undefined;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nfunction difference(array1, array2) {\n  return array1.filter(x => array2.indexOf(x) === -1);\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n\n  return { ...arg2,\n    queryKey: arg1\n  };\n}\nfunction parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2\n      };\n    }\n\n    return { ...arg2,\n      mutationKey: arg1\n    };\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2,\n      mutationFn: arg1\n    };\n  }\n\n  return { ...arg1\n  };\n}\nfunction parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    queryKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    mutationKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive();\n\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    fetching,\n    predicate,\n    mutationKey\n  } = filters;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\n\nfunction hashQueryKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nfunction partialMatchKey(a, b) {\n  return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  const ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  const prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\nfunction getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n}\nfunction replaceData(prevData, data, options) {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n    return prevData;\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n\n  return data;\n}\n\nexport { difference, functionalUpdate, getAbortController, hashQueryKey, hashQueryKeyByOptions, isError, isPlainArray, isPlainObject, isQueryKey, isServer, isValidTimeout, matchMutation, matchQuery, noop, parseFilterArgs, parseMutationArgs, parseMutationFilterArgs, parseQueryArgs, partialDeepEqual, partialMatchKey, replaceAt, replaceData, replaceEqualDeep, scheduleMicrotask, shallowEqualObjects, sleep, timeUntilStale };\n//# sourceMappingURL=utils.mjs.map\n","import { Subscribable } from './subscribable.mjs';\nimport { isServer } from './utils.mjs';\n\nclass FocusManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onFocus => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus(); // Listen to visibillitychange and focus\n\n\n        window.addEventListener('visibilitychange', listener, false);\n        window.addEventListener('focus', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener);\n          window.removeEventListener('focus', listener);\n        };\n      }\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(focused => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n\n  setFocused(focused) {\n    this.focused = focused;\n\n    if (focused) {\n      this.onFocus();\n    }\n  }\n\n  onFocus() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n\n  isFocused() {\n    if (typeof this.focused === 'boolean') {\n      return this.focused;\n    } // document global can be unavailable in react native\n\n\n    if (typeof document === 'undefined') {\n      return true;\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(document.visibilityState);\n  }\n\n}\nconst focusManager = new FocusManager();\n\nexport { FocusManager, focusManager };\n//# sourceMappingURL=focusManager.mjs.map\n","import { Subscribable } from './subscribable.mjs';\nimport { isServer } from './utils.mjs';\n\nclass OnlineManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onOnline => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline(); // Listen to online\n\n\n        window.addEventListener('online', listener, false);\n        window.addEventListener('offline', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', listener);\n          window.removeEventListener('offline', listener);\n        };\n      }\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(online => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online);\n      } else {\n        this.onOnline();\n      }\n    });\n  }\n\n  setOnline(online) {\n    this.online = online;\n\n    if (online) {\n      this.onOnline();\n    }\n  }\n\n  onOnline() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n\n  isOnline() {\n    if (typeof this.online === 'boolean') {\n      return this.online;\n    }\n\n    if (typeof navigator === 'undefined' || typeof navigator.onLine === 'undefined') {\n      return true;\n    }\n\n    return navigator.onLine;\n  }\n\n}\nconst onlineManager = new OnlineManager();\n\nexport { OnlineManager, onlineManager };\n//# sourceMappingURL=onlineManager.mjs.map\n","import { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { sleep } from './utils.mjs';\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\n\nfunction canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nclass CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n\n}\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        if (isResolved || !shouldPause()) {\n          return continueResolve(value);\n        }\n      };\n\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      continueFn == null ? void 0 : continueFn();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}\n\nexport { CancelledError, canFetch, createRetryer, isCancelledError };\n//# sourceMappingURL=retryer.mjs.map\n","const defaultLogger = console;\n\nexport { defaultLogger };\n//# sourceMappingURL=logger.mjs.map\n","import { scheduleMicrotask } from './utils.mjs';\n\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n\n  let notifyFn = callback => {\n    callback();\n  };\n\n  let batchNotifyFn = callback => {\n    callback();\n  };\n\n  const batch = callback => {\n    let result;\n    transactions++;\n\n    try {\n      result = callback();\n    } finally {\n      transactions--;\n\n      if (!transactions) {\n        flush();\n      }\n    }\n\n    return result;\n  };\n\n  const schedule = callback => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n\n\n  const batchCalls = callback => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args);\n      });\n    };\n  };\n\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach(callback => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n\n\n  const setNotifyFunction = fn => {\n    notifyFn = fn;\n  };\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n\n\n  const setBatchNotifyFunction = fn => {\n    batchNotifyFn = fn;\n  };\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction\n  };\n} // SINGLETON\n\nconst notifyManager = createNotifyManager();\n\nexport { createNotifyManager, notifyManager };\n//# sourceMappingURL=notifyManager.mjs.map\n","import { isValidTimeout, isServer } from './utils.mjs';\n\nclass Removable {\n  destroy() {\n    this.clearGcTimeout();\n  }\n\n  scheduleGc() {\n    this.clearGcTimeout();\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.cacheTime);\n    }\n  }\n\n  updateCacheTime(newCacheTime) {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1000);\n  }\n\n  clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout);\n      this.gcTimeout = undefined;\n    }\n  }\n\n}\n\nexport { Removable };\n//# sourceMappingURL=removable.mjs.map\n","import { replaceData, noop, timeUntilStale, getAbortController } from './utils.mjs';\nimport { defaultLogger } from './logger.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { createRetryer, isCancelledError, canFetch } from './retryer.mjs';\nimport { Removable } from './removable.mjs';\n\n// CLASS\nclass Query extends Removable {\n  constructor(config) {\n    super();\n    this.abortSignalConsumed = false;\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.logger = config.logger || defaultLogger;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || getDefaultState(this.options);\n    this.state = this.initialState;\n    this.meta = config.meta;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.meta = options == null ? void 0 : options.meta;\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this);\n    }\n  }\n\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n      manual: options == null ? void 0 : options.manual\n    });\n    return data;\n  }\n\n  setState(state, setStateOptions) {\n    this.dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n\n  cancel(options) {\n    var _this$retryer;\n\n    const promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n\n  reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  }\n\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);\n  }\n\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n\n  onFocus() {\n    var _this$retryer2;\n\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  }\n\n  onOnline() {\n    var _this$retryer3;\n\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter(x => x !== observer);\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n\n        this.scheduleGc();\n      }\n\n      this.cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  getObserversCount() {\n    return this.observers.length;\n  }\n\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.promise) {\n        var _this$retryer4;\n\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n        return this.promise;\n      }\n    } // Update config if passed, otherwise the config from the last execution is used\n\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n\n    const abortController = getAbortController(); // Create query function context\n\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta\n    }; // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true;\n            return abortController.signal;\n          }\n\n          return undefined;\n        }\n      });\n    };\n\n    addSignalProperty(queryFnContext); // Create fetch function\n\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject('Missing queryFn');\n      }\n\n      this.abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    }; // Trigger behavior hook\n\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n      meta: this.meta\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n    this.revertState = this.state; // Set to fetching state if not already in it\n\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n\n      if (!isCancelledError(error)) {\n        var _this$cache$config$on, _this$cache$config;\n\n        // Notify cache callback\n        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n\n      this.isFetchingOptimistic = false;\n    }; // Try to fetch the data\n\n\n    this.retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _this$cache$config$on2, _this$cache$config2;\n\n        if (typeof data === 'undefined') {\n          if (process.env.NODE_ENV !== 'production') {\n            this.logger.error(\"Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: \" + this.queryHash);\n          }\n\n          onError(new Error('undefined'));\n          return;\n        }\n\n        this.setData(data); // Notify cache callback\n\n        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, data, this);\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.dispatch({\n          type: 'failed',\n          failureCount,\n          error\n        });\n      },\n      onPause: () => {\n        this.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.promise = this.retryer.promise;\n    return this.promise;\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      var _action$meta, _action$dataUpdatedAt;\n\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n\n        case 'pause':\n          return { ...state,\n            fetchStatus: 'paused'\n          };\n\n        case 'continue':\n          return { ...state,\n            fetchStatus: 'fetching'\n          };\n\n        case 'fetch':\n          return { ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            })\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            })\n          };\n\n        case 'error':\n          const error = action.error;\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState\n            };\n          }\n\n          return { ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n\n        case 'invalidate':\n          return { ...state,\n            isInvalidated: true\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action);\n      });\n      this.cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\n\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasInitialData = typeof options.initialData !== 'undefined';\n  const initialDataUpdatedAt = hasInitialData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  const hasData = typeof data !== 'undefined';\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}\n\nexport { Query };\n//# sourceMappingURL=query.mjs.map\n","import { hashQueryKeyByOptions, parseFilterArgs, matchQuery } from './utils.mjs';\nimport { Query } from './query.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\n// CLASS\nclass QueryCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.queries = [];\n    this.queriesMap = {};\n  }\n\n  build(client, options, state) {\n    var _options$queryHash;\n\n    const queryKey = options.queryKey;\n    const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n        meta: options.meta\n      });\n      this.add(query);\n    }\n\n    return query;\n  }\n\n  add(query) {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query;\n      this.queries.push(query);\n      this.notify({\n        type: 'added',\n        query\n      });\n    }\n  }\n\n  remove(query) {\n    const queryInMap = this.queriesMap[query.queryHash];\n\n    if (queryInMap) {\n      query.destroy();\n      this.queries = this.queries.filter(x => x !== query);\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash];\n      }\n\n      this.notify({\n        type: 'removed',\n        query\n      });\n    }\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        this.remove(query);\n      });\n    });\n  }\n\n  get(queryHash) {\n    return this.queriesMap[queryHash];\n  }\n\n  getAll() {\n    return this.queries;\n  }\n\n  find(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.queries.find(query => matchQuery(filters, query));\n  }\n\n  findAll(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    return Object.keys(filters).length > 0 ? this.queries.filter(query => matchQuery(filters, query)) : this.queries;\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n\n  onFocus() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onFocus();\n      });\n    });\n  }\n\n  onOnline() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onOnline();\n      });\n    });\n  }\n\n}\n\nexport { QueryCache };\n//# sourceMappingURL=queryCache.mjs.map\n","import { defaultLogger } from './logger.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Removable } from './removable.mjs';\nimport { createRetryer, canFetch } from './retryer.mjs';\n\n// CLASS\nclass Mutation extends Removable {\n  constructor(config) {\n    super();\n    this.options = { ...config.defaultOptions,\n      ...config.options\n    };\n    this.mutationId = config.mutationId;\n    this.mutationCache = config.mutationCache;\n    this.logger = config.logger || defaultLogger;\n    this.observers = [];\n    this.state = config.state || getDefaultState();\n    this.meta = config.meta;\n    this.updateCacheTime(this.options.cacheTime);\n    this.scheduleGc();\n  }\n\n  setState(state) {\n    this.dispatch({\n      type: 'setState',\n      state\n    });\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the mutation from being garbage collected\n\n      this.clearGcTimeout();\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    this.observers = this.observers.filter(x => x !== observer);\n    this.scheduleGc();\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer\n    });\n  }\n\n  optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc();\n      } else {\n        this.mutationCache.remove(this);\n      }\n    }\n  }\n\n  continue() {\n    if (this.retryer) {\n      this.retryer.continue();\n      return this.retryer.promise;\n    }\n\n    return this.execute();\n  }\n\n  async execute() {\n    const executeMutation = () => {\n      var _this$options$retry;\n\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found');\n          }\n\n          return this.options.mutationFn(this.state.variables);\n        },\n        onFail: (failureCount, error) => {\n          this.dispatch({\n            type: 'failed',\n            failureCount,\n            error\n          });\n        },\n        onPause: () => {\n          this.dispatch({\n            type: 'pause'\n          });\n        },\n        onContinue: () => {\n          this.dispatch({\n            type: 'continue'\n          });\n        },\n        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode\n      });\n      return this.retryer.promise;\n    };\n\n    const restored = this.state.status === 'loading';\n\n    try {\n      var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$options$onSettl, _this$options3;\n\n      if (!restored) {\n        var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;\n\n        this.dispatch({\n          type: 'loading',\n          variables: this.options.variables\n        }); // Notify cache callback\n\n        await ((_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this));\n        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));\n\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables\n          });\n        }\n      }\n\n      const data = await executeMutation(); // Notify cache callback\n\n      await ((_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this));\n      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context));\n      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));\n      this.dispatch({\n        type: 'success',\n        data\n      });\n      return data;\n    } catch (error) {\n      try {\n        var _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onError, _this$options4, _this$options$onSettl2, _this$options5;\n\n        // Notify cache callback\n        await ((_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, error, this.state.variables, this.state.context, this));\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n\n        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context));\n        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, undefined, error, this.state.variables, this.state.context));\n        throw error;\n      } finally {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n    }\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error\n          };\n\n        case 'pause':\n          return { ...state,\n            isPaused: true\n          };\n\n        case 'continue':\n          return { ...state,\n            isPaused: false\n          };\n\n        case 'loading':\n          return { ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false\n          };\n\n        case 'error':\n          return { ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error'\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onMutationUpdate(action);\n      });\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\nfunction getDefaultState() {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined\n  };\n}\n\nexport { Mutation, getDefaultState };\n//# sourceMappingURL=mutation.mjs.map\n","import { notifyManager } from './notifyManager.mjs';\nimport { Mutation } from './mutation.mjs';\nimport { matchMutation, noop } from './utils.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\n// CLASS\nclass MutationCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.mutations = [];\n    this.mutationId = 0;\n  }\n\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : undefined,\n      meta: options.meta\n    });\n    this.add(mutation);\n    return mutation;\n  }\n\n  add(mutation) {\n    this.mutations.push(mutation);\n    this.notify({\n      type: 'added',\n      mutation\n    });\n  }\n\n  remove(mutation) {\n    this.mutations = this.mutations.filter(x => x !== mutation);\n    this.notify({\n      type: 'removed',\n      mutation\n    });\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.mutations.forEach(mutation => {\n        this.remove(mutation);\n      });\n    });\n  }\n\n  getAll() {\n    return this.mutations;\n  }\n\n  find(filters) {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.mutations.find(mutation => matchMutation(filters, mutation));\n  }\n\n  findAll(filters) {\n    return this.mutations.filter(mutation => matchMutation(filters, mutation));\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n\n  resumePausedMutations() {\n    const pausedMutations = this.mutations.filter(x => x.state.isPaused);\n    return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));\n  }\n\n}\n\nexport { MutationCache };\n//# sourceMappingURL=mutationCache.mjs.map\n","function infiniteQueryBehavior() {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n\n        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        let newPageParams = oldPageParams;\n        let cancelled = false;\n\n        const addSignalProperty = object => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              var _context$signal;\n\n              if ((_context$signal = context.signal) != null && _context$signal.aborted) {\n                cancelled = true;\n              } else {\n                var _context$signal2;\n\n                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener('abort', () => {\n                  cancelled = true;\n                });\n              }\n\n              return context.signal;\n            }\n          });\n        }; // Get query function\n\n\n        const queryFn = context.options.queryFn || (() => Promise.reject('Missing queryFn'));\n\n        const buildNewPages = (pages, param, page, previous) => {\n          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];\n          return previous ? [page, ...pages] : [...pages, page];\n        }; // Create function to fetch a page\n\n\n        const fetchPage = (pages, manual, param, previous) => {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.meta\n          };\n          addSignalProperty(queryFnContext);\n          const queryFnResult = queryFn(queryFnContext);\n          const promise = Promise.resolve(queryFnResult).then(page => buildNewPages(pages, param, page, previous));\n          return promise;\n        };\n\n        let promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param);\n        } // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param, true);\n        } // Refetch pages\n        else {\n          newPageParams = [];\n          const manual = typeof context.options.getNextPageParam === 'undefined';\n          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n\n              if (shouldFetchNextPage) {\n                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                return fetchPage(pages, manual, param);\n              }\n\n              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n            });\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams\n        }));\n        return finalPromise;\n      };\n    }\n  };\n}\nfunction getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nfunction getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n}\n\nexport { getNextPageParam, getPreviousPageParam, hasNextPage, hasPreviousPage, infiniteQueryBehavior };\n//# sourceMappingURL=infiniteQueryBehavior.mjs.map\n","import { shallowEqualObjects, noop, isServer, isValidTimeout, timeUntilStale, replaceData } from './utils.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { focusManager } from './focusManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\nimport { canFetch, isCancelledError } from './retryer.mjs';\n\nclass QueryObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.options = options;\n    this.trackedProps = new Set();\n    this.selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n\n  bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\n  }\n\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n    this.currentQuery.removeObserver(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryOptions(options);\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.currentQuery,\n        observer: this\n      });\n    }\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery();\n    const mounted = this.hasListeners(); // Fetch if there are subscribers\n\n    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\n      this.executeFetch();\n    } // Update result\n\n\n    this.updateResult(notifyOptions); // Update stale interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.updateStaleTimeout();\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\n      this.updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n\n  getOptimisticResult(options) {\n    const query = this.client.getQueryCache().build(this.client, options);\n    return this.createResult(query, options);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n\n  getCurrentQuery() {\n    return this.currentQuery;\n  }\n\n  remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  }\n\n  refetch({\n    refetchPage,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        refetchPage\n      }\n    });\n  }\n\n  fetchOptimistic(options) {\n    const defaultedOptions = this.client.defaultQueryOptions(options);\n    const query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n\n  fetch(fetchOptions) {\n    var _fetchOptions$cancelR;\n\n    return this.executeFetch({ ...fetchOptions,\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true\n    }).then(() => {\n      this.updateResult();\n      return this.currentResult;\n    });\n  }\n\n  executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    let promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions != null && fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  updateStaleTimeout() {\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    const timeout = time + 1;\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n\n  computeRefetchInterval() {\n    var _this$options$refetch;\n\n    return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\n  }\n\n  updateRefetchInterval(nextInterval) {\n    this.clearRefetchInterval();\n    this.currentRefetchInterval = nextInterval;\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.executeFetch();\n      }\n    }, this.currentRefetchInterval);\n  }\n\n  updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval(this.computeRefetchInterval());\n  }\n\n  clearStaleTimeout() {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId);\n      this.staleTimeoutId = undefined;\n    }\n  }\n\n  clearRefetchInterval() {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId);\n      this.refetchIntervalId = undefined;\n    }\n  }\n\n  createResult(query, options) {\n    const prevQuery = this.currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.currentResult;\n    const prevResultState = this.currentResultState;\n    const prevResultOptions = this.currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\n    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\n    const {\n      state\n    } = query;\n    let {\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      fetchStatus,\n      status\n    } = state;\n    let isPreviousData = false;\n    let isPlaceholderData = false;\n    let data; // Optimistically set result in fetching state if needed\n\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? 'fetching' : 'paused';\n\n        if (!dataUpdatedAt) {\n          status = 'loading';\n        }\n      }\n\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle';\n      }\n    } // Keep previous data if needed\n\n\n    if (options.keepPreviousData && !state.dataUpdateCount && prevQueryResult != null && prevQueryResult.isSuccess && status !== 'error') {\n      data = prevQueryResult.data;\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt;\n      status = prevQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {\n        data = this.selectResult;\n      } else {\n        try {\n          this.selectFn = options.select;\n          data = options.select(state.data);\n          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\n          this.selectResult = data;\n          this.selectError = null;\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError);\n          }\n\n          this.selectError = selectError;\n        }\n      }\n    } // Use query data\n    else {\n      data = state.data;\n    } // Show placeholder data if needed\n\n\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      let placeholderData; // Memoize placeholder data\n\n      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\n\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData);\n            this.selectError = null;\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError);\n            }\n\n            this.selectError = selectError;\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);\n        isPlaceholderData = true;\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError;\n      data = this.selectResult;\n      errorUpdatedAt = Date.now();\n      status = 'error';\n    }\n\n    const isFetching = fetchStatus === 'fetching';\n    const isLoading = status === 'loading';\n    const isError = status === 'error';\n    const result = {\n      status,\n      fetchStatus,\n      isLoading,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading && isFetching,\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isLoading,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove\n    };\n    return result;\n  }\n\n  updateResult(notifyOptions) {\n    const prevResult = this.currentResult;\n    const nextResult = this.createResult(this.currentQuery, this.options);\n    this.currentResultState = this.currentQuery.state;\n    this.currentResultOptions = this.options; // Only notify and update result if something has changed\n\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n\n    this.currentResult = nextResult; // Determine which callbacks to trigger\n\n    const defaultNotifyOptions = {\n      cache: true\n    };\n\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n\n      const {\n        notifyOnChangeProps\n      } = this.options;\n\n      if (notifyOnChangeProps === 'all' || !notifyOnChangeProps && !this.trackedProps.size) {\n        return true;\n      }\n\n      const includedProps = new Set(notifyOnChangeProps != null ? notifyOnChangeProps : this.trackedProps);\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error');\n      }\n\n      return Object.keys(this.currentResult).some(key => {\n        const typedKey = key;\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n\n    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n\n    this.notify({ ...defaultNotifyOptions,\n      ...notifyOptions\n    });\n  }\n\n  updateQuery() {\n    const query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === this.currentQuery) {\n      return;\n    }\n\n    const prevQuery = this.currentQuery;\n    this.currentQuery = query;\n    this.currentQueryInitialState = query.state;\n    this.previousQueryResult = this.currentResult;\n\n    if (this.hasListeners()) {\n      prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n\n  onQueryUpdate(action) {\n    const notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual;\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true;\n    }\n\n    this.updateResult(notifyOptions);\n\n    if (this.hasListeners()) {\n      this.updateTimers();\n    }\n  }\n\n  notify(notifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;\n\n        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);\n        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;\n\n        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);\n        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, undefined, this.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated'\n        });\n      }\n    });\n  }\n\n}\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n}\n\nexport { QueryObserver };\n//# sourceMappingURL=queryObserver.mjs.map\n","import { difference, replaceAt } from './utils.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { QueryObserver } from './queryObserver.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\nclass QueriesObserver extends Subscribable {\n  constructor(client, queries) {\n    super();\n    this.client = client;\n    this.queries = [];\n    this.result = [];\n    this.observers = [];\n    this.observersMap = {};\n\n    if (queries) {\n      this.setQueries(queries);\n    }\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n\n  setQueries(queries, notifyOptions) {\n    this.queries = queries;\n    notifyManager.batch(() => {\n      const prevObservers = this.observers;\n      const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes\n\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n\n      this.observers = newObservers;\n      this.observersMap = newObserversMap;\n      this.result = newResult;\n\n      if (!this.hasListeners()) {\n        return;\n      }\n\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n      this.notify();\n    });\n  }\n\n  getCurrentResult() {\n    return this.result;\n  }\n\n  getQueries() {\n    return this.observers.map(observer => observer.getCurrentQuery());\n  }\n\n  getOptimisticResult(queries) {\n    return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n  }\n\n  findMatchingObservers(queries) {\n    const prevObservers = this.observers;\n    const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObservers.find(observer => observer.options.queryHash === defaultedOptions.queryHash);\n\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n\n      return [];\n    });\n    const matchedQueryHashes = matchingObservers.map(match => match.defaultedQueryOptions.queryHash);\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.includes(defaultedOptions.queryHash));\n    const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObservers.some(match => match.observer === prevObserver));\n\n    const getObserver = options => {\n      const defaultedOptions = this.client.defaultQueryOptions(options);\n      const currentObserver = this.observersMap[defaultedOptions.queryHash];\n      return currentObserver != null ? currentObserver : new QueryObserver(this.client, defaultedOptions);\n    };\n\n    const newOrReusedObservers = unmatchedQueries.map((options, index) => {\n      if (options.keepPreviousData) {\n        // return previous data from one of the observers that no longer match\n        const previouslyUsedObserver = unmatchedObservers[index];\n\n        if (previouslyUsedObserver !== undefined) {\n          return {\n            defaultedQueryOptions: options,\n            observer: previouslyUsedObserver\n          };\n        }\n      }\n\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n\n  onUpdate(observer, result) {\n    const index = this.observers.indexOf(observer);\n\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result);\n      this.notify();\n    }\n  }\n\n  notify() {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(this.result);\n      });\n    });\n  }\n\n}\n\nexport { QueriesObserver };\n//# sourceMappingURL=queriesObserver.mjs.map\n","import { QueryObserver } from './queryObserver.mjs';\nimport { infiniteQueryBehavior, hasNextPage, hasPreviousPage } from './infiniteQueryBehavior.mjs';\n\nclass InfiniteQueryObserver extends QueryObserver {\n  // Type override\n  // Type override\n  // Type override\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(client, options) {\n    super(client, options);\n  }\n\n  bindMethods() {\n    super.bindMethods();\n    this.fetchNextPage = this.fetchNextPage.bind(this);\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    super.setOptions({ ...options,\n      behavior: infiniteQueryBehavior()\n    }, notifyOptions);\n  }\n\n  getOptimisticResult(options) {\n    options.behavior = infiniteQueryBehavior();\n    return super.getOptimisticResult(options);\n  }\n\n  fetchNextPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'forward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  fetchPreviousPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'backward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  createResult(query, options) {\n    var _state$data, _state$data2, _state$fetchMeta, _state$fetchMeta$fetc, _state$fetchMeta2, _state$fetchMeta2$fet;\n\n    const {\n      state\n    } = query;\n    const result = super.createResult(query, options);\n    return { ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, (_state$data = state.data) == null ? void 0 : _state$data.pages),\n      hasPreviousPage: hasPreviousPage(options, (_state$data2 = state.data) == null ? void 0 : _state$data2.pages),\n      isFetchingNextPage: state.fetchStatus === 'fetching' && ((_state$fetchMeta = state.fetchMeta) == null ? void 0 : (_state$fetchMeta$fetc = _state$fetchMeta.fetchMore) == null ? void 0 : _state$fetchMeta$fetc.direction) === 'forward',\n      isFetchingPreviousPage: state.fetchStatus === 'fetching' && ((_state$fetchMeta2 = state.fetchMeta) == null ? void 0 : (_state$fetchMeta2$fet = _state$fetchMeta2.fetchMore) == null ? void 0 : _state$fetchMeta2$fet.direction) === 'backward'\n    };\n  }\n\n}\n\nexport { InfiniteQueryObserver };\n//# sourceMappingURL=infiniteQueryObserver.mjs.map\n","import { getDefaultState } from './mutation.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\nimport { shallowEqualObjects } from './utils.mjs';\n\n// CLASS\nclass MutationObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.updateResult();\n  }\n\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n\n  setOptions(options) {\n    const prevOptions = this.options;\n    this.options = this.client.defaultMutationOptions(options);\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.currentMutation,\n        observer: this\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      var _this$currentMutation;\n\n      (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.removeObserver(this);\n    }\n  }\n\n  onMutationUpdate(action) {\n    this.updateResult(); // Determine which callbacks to trigger\n\n    const notifyOptions = {\n      listeners: true\n    };\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true;\n    }\n\n    this.notify(notifyOptions);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  reset() {\n    this.currentMutation = undefined;\n    this.updateResult();\n    this.notify({\n      listeners: true\n    });\n  }\n\n  mutate(variables, options) {\n    this.mutateOptions = options;\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this);\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, { ...this.options,\n      variables: typeof variables !== 'undefined' ? variables : this.options.variables\n    });\n    this.currentMutation.addObserver(this);\n    return this.currentMutation.execute();\n  }\n\n  updateResult() {\n    const state = this.currentMutation ? this.currentMutation.state : getDefaultState();\n    const result = { ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset\n    };\n    this.currentResult = result;\n  }\n\n  notify(options) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions) {\n        if (options.onSuccess) {\n          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;\n\n          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);\n        } else if (options.onError) {\n          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;\n\n          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, undefined, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n        }\n      } // Then trigger the listeners\n\n\n      if (options.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult);\n        });\n      }\n    });\n  }\n\n}\n\nexport { MutationObserver };\n//# sourceMappingURL=mutationObserver.mjs.map\n","// TYPES\n// FUNCTIONS\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state\n  };\n} // Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\n\n\nfunction dehydrateQuery(query) {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash\n  };\n}\n\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\n\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === 'success';\n}\n\nfunction dehydrate(client, options = {}) {\n  const mutations = [];\n  const queries = [];\n\n  if (options.dehydrateMutations !== false) {\n    const shouldDehydrateMutation = options.shouldDehydrateMutation || defaultShouldDehydrateMutation;\n    client.getMutationCache().getAll().forEach(mutation => {\n      if (shouldDehydrateMutation(mutation)) {\n        mutations.push(dehydrateMutation(mutation));\n      }\n    });\n  }\n\n  if (options.dehydrateQueries !== false) {\n    const shouldDehydrateQuery = options.shouldDehydrateQuery || defaultShouldDehydrateQuery;\n    client.getQueryCache().getAll().forEach(query => {\n      if (shouldDehydrateQuery(query)) {\n        queries.push(dehydrateQuery(query));\n      }\n    });\n  }\n\n  return {\n    mutations,\n    queries\n  };\n}\nfunction hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return;\n  }\n\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache(); // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const mutations = dehydratedState.mutations || []; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(dehydratedMutation => {\n    var _options$defaultOptio;\n\n    mutationCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio = options.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations),\n      mutationKey: dehydratedMutation.mutationKey\n    }, dehydratedMutation.state);\n  });\n  queries.forEach(dehydratedQuery => {\n    var _options$defaultOptio2;\n\n    const query = queryCache.get(dehydratedQuery.queryHash); // Do not hydrate if an existing query exists with newer data\n\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQuery.state.dataUpdatedAt) {\n        query.setState(dehydratedQuery.state);\n      }\n\n      return;\n    } // Restore query\n\n\n    queryCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio2 = options.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries),\n      queryKey: dehydratedQuery.queryKey,\n      queryHash: dehydratedQuery.queryHash\n    }, dehydratedQuery.state);\n  });\n}\n\nexport { dehydrate, hydrate };\n//# sourceMappingURL=hydration.mjs.map\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { QueryKey, MutationKey } from '@tanstack/query-core'\nimport { isRef, unref } from 'vue-demi'\nimport type { UnwrapRef } from 'vue-demi'\n\nexport const VUE_QUERY_CLIENT = 'VUE_QUERY_CLIENT'\n\nexport function getClientKey(key?: string) {\n  const suffix = key ? `:${key}` : ''\n  return `${VUE_QUERY_CLIENT}${suffix}`\n}\n\nexport function isQueryKey(value: unknown): value is QueryKey {\n  return Array.isArray(value)\n}\n\nexport function isMutationKey(value: unknown): value is MutationKey {\n  return Array.isArray(value)\n}\n\nexport function updateState(\n  state: Record<string, unknown>,\n  update: Record<string, any>,\n): void {\n  Object.keys(state).forEach((key) => {\n    state[key] = update[key]\n  })\n}\n\nexport function cloneDeep<T>(\n  value: T,\n  customizer?: (val: unknown) => unknown | void,\n): T {\n  if (customizer) {\n    const result = customizer(value)\n    if (result !== undefined || isRef(value)) {\n      return result as typeof value\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return value.map((val) => cloneDeep(val, customizer)) as typeof value\n  }\n\n  if (typeof value === 'object' && isPlainObject(value)) {\n    const entries = Object.entries(value).map(([key, val]) => [\n      key,\n      cloneDeep(val, customizer),\n    ])\n    return Object.fromEntries(entries)\n  }\n\n  return value\n}\n\nexport function cloneDeepUnref<T>(obj: T): UnwrapRef<T> {\n  return cloneDeep(obj, (val) => {\n    if (isRef(val)) {\n      return cloneDeepUnref(unref(val))\n    }\n  }) as UnwrapRef<typeof obj>\n}\n\nfunction isPlainObject(value: unknown): value is Object {\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(value)\n  return prototype === null || prototype === Object.prototype\n}\n","import { getCurrentInstance, inject } from 'vue-demi'\n\nimport type { QueryClient } from './queryClient'\nimport { getClientKey } from './utils'\n\nexport function useQueryClient(id = ''): QueryClient {\n  const vm = getCurrentInstance()?.proxy\n\n  if (!vm) {\n    throw new Error('vue-query hooks can only be used inside setup() function.')\n  }\n\n  const key = getClientKey(id)\n  const queryClient = inject<QueryClient>(key)\n\n  if (!queryClient) {\n    throw new Error(\n      \"No 'queryClient' found in Vue context, use 'VueQueryPlugin' to properly initialize the library.\",\n    )\n  }\n\n  return queryClient\n}\n","import { QueryCache as QC } from '@tanstack/query-core'\nimport type { Query, QueryKey, QueryFilters } from '@tanstack/query-core'\nimport type { MaybeRefDeep } from './types'\nimport { cloneDeepUnref, isQueryKey } from './utils'\n\nexport class QueryCache extends QC {\n  find<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    arg1: MaybeRefDeep<QueryKey>,\n    arg2?: MaybeRefDeep<QueryFilters>,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2) as QueryFilters\n    return super.find(arg1Unreffed, arg2Unreffed)\n  }\n\n  findAll(\n    queryKey?: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<QueryFilters>,\n  ): Query[]\n  findAll(filters?: MaybeRefDeep<QueryFilters>): Query[]\n  findAll(\n    arg1?: MaybeRefDeep<QueryKey | QueryFilters>,\n    arg2?: MaybeRefDeep<QueryFilters>,\n  ): Query[]\n  findAll(\n    arg1?: MaybeRefDeep<QueryKey> | MaybeRefDeep<QueryFilters>,\n    arg2?: MaybeRefDeep<QueryFilters>,\n  ): Query[] {\n    const arg1Unreffed = cloneDeepUnref(arg1) as QueryKey | QueryFilters\n    const arg2Unreffed = cloneDeepUnref(arg2) as QueryFilters\n    if (isQueryKey(arg1Unreffed)) {\n      return super.findAll(arg1Unreffed, arg2Unreffed)\n    }\n    return super.findAll(arg1Unreffed)\n  }\n}\n","import { MutationCache as MC } from '@tanstack/query-core'\nimport type { Mutation, MutationFilters } from '@tanstack/query-core'\nimport type { MaybeRefDeep } from './types'\nimport { cloneDeepUnref } from './utils'\n\nexport class MutationCache extends MC {\n  find<TData = unknown, TError = unknown, TVariables = any, TContext = unknown>(\n    filters: MaybeRefDeep<MutationFilters>,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    return super.find(cloneDeepUnref(filters) as MutationFilters)\n  }\n\n  findAll(filters: MaybeRefDeep<MutationFilters>): Mutation[] {\n    return super.findAll(cloneDeepUnref(filters) as MutationFilters)\n  }\n}\n","import { QueryClient as QC } from '@tanstack/query-core'\nimport type {\n  QueryKey,\n  QueryClientConfig,\n  SetDataOptions,\n  ResetQueryFilters,\n  ResetOptions,\n  CancelOptions,\n  InvalidateQueryFilters,\n  InvalidateOptions,\n  RefetchQueryFilters,\n  RefetchOptions,\n  FetchQueryOptions,\n  QueryFunction,\n  FetchInfiniteQueryOptions,\n  InfiniteData,\n  DefaultOptions,\n  QueryObserverOptions,\n  MutationKey,\n  MutationObserverOptions,\n  QueryFilters,\n  MutationFilters,\n  QueryState,\n  Updater,\n} from '@tanstack/query-core'\nimport type { MaybeRefDeep } from './types'\nimport { cloneDeepUnref, isQueryKey } from './utils'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\n\nexport class QueryClient extends QC {\n  constructor(config: MaybeRefDeep<QueryClientConfig> = {}) {\n    const unreffedConfig = cloneDeepUnref(config) as QueryClientConfig\n    const vueQueryConfig: QueryClientConfig = {\n      logger: cloneDeepUnref(unreffedConfig.logger),\n      defaultOptions: cloneDeepUnref(unreffedConfig.defaultOptions),\n      queryCache: unreffedConfig.queryCache || new QueryCache(),\n      mutationCache: unreffedConfig.mutationCache || new MutationCache(),\n    }\n    super(vueQueryConfig)\n  }\n\n  isFetching(filters?: MaybeRefDeep<QueryFilters>): number\n  isFetching(\n    queryKey?: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<QueryFilters>,\n  ): number\n  isFetching(\n    arg1?: MaybeRefDeep<QueryFilters | QueryKey>,\n    arg2?: MaybeRefDeep<QueryFilters>,\n  ): number {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2) as QueryFilters\n    if (isQueryKey(arg1Unreffed)) {\n      return super.isFetching(arg1Unreffed, arg2Unreffed)\n    }\n    return super.isFetching(arg1Unreffed as QueryFilters)\n  }\n\n  isMutating(filters?: MaybeRefDeep<MutationFilters>): number {\n    return super.isMutating(cloneDeepUnref(filters) as MutationFilters)\n  }\n\n  getQueryData<TData = unknown>(\n    queryKey: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<QueryFilters>,\n  ): TData | undefined {\n    return super.getQueryData(\n      cloneDeepUnref(queryKey),\n      cloneDeepUnref(filters) as QueryFilters,\n    )\n  }\n\n  getQueriesData<TData = unknown>(\n    queryKey: MaybeRefDeep<QueryKey>,\n  ): [QueryKey, TData | undefined][]\n  getQueriesData<TData = unknown>(\n    filters: MaybeRefDeep<QueryFilters>,\n  ): [QueryKey, TData | undefined][]\n  getQueriesData<TData = unknown>(\n    queryKeyOrFilters: MaybeRefDeep<QueryKey> | MaybeRefDeep<QueryFilters>,\n  ): [QueryKey, TData | undefined][] {\n    const unreffed = cloneDeepUnref(queryKeyOrFilters)\n    if (isQueryKey(unreffed)) {\n      return super.getQueriesData(unreffed)\n    }\n    return super.getQueriesData(unreffed as QueryFilters)\n  }\n\n  setQueryData<TData>(\n    queryKey: MaybeRefDeep<QueryKey>,\n    updater: Updater<TData | undefined, TData | undefined>,\n    options?: MaybeRefDeep<SetDataOptions>,\n  ): TData | undefined {\n    return super.setQueryData(\n      cloneDeepUnref(queryKey),\n      updater,\n      cloneDeepUnref(options) as SetDataOptions,\n    )\n  }\n\n  setQueriesData<TData>(\n    queryKey: MaybeRefDeep<QueryKey>,\n    updater: Updater<TData | undefined, TData | undefined>,\n    options?: MaybeRefDeep<SetDataOptions>,\n  ): [QueryKey, TData | undefined][]\n  setQueriesData<TData>(\n    filters: MaybeRefDeep<QueryFilters>,\n    updater: Updater<TData | undefined, TData | undefined>,\n    options?: MaybeRefDeep<SetDataOptions>,\n  ): [QueryKey, TData | undefined][]\n  setQueriesData<TData>(\n    queryKeyOrFilters: MaybeRefDeep<QueryKey | QueryFilters>,\n    updater: Updater<TData | undefined, TData | undefined>,\n    options?: MaybeRefDeep<SetDataOptions>,\n  ): [QueryKey, TData | undefined][] {\n    const arg1Unreffed = cloneDeepUnref(queryKeyOrFilters)\n    const arg3Unreffed = cloneDeepUnref(options) as SetDataOptions\n    if (isQueryKey(arg1Unreffed)) {\n      return super.setQueriesData(arg1Unreffed, updater, arg3Unreffed)\n    }\n    return super.setQueriesData(\n      arg1Unreffed as QueryFilters,\n      updater,\n      arg3Unreffed,\n    )\n  }\n\n  getQueryState<TData = unknown, TError = undefined>(\n    queryKey: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<QueryFilters>,\n  ): QueryState<TData, TError> | undefined {\n    return super.getQueryState(\n      cloneDeepUnref(queryKey),\n      cloneDeepUnref(filters) as QueryFilters,\n    )\n  }\n\n  removeQueries(filters?: MaybeRefDeep<QueryFilters>): void\n  removeQueries(\n    queryKey?: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<QueryFilters>,\n  ): void\n  removeQueries(\n    arg1?: MaybeRefDeep<QueryKey | QueryFilters>,\n    arg2?: MaybeRefDeep<QueryFilters>,\n  ): void {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    if (isQueryKey(arg1Unreffed)) {\n      return super.removeQueries(\n        arg1Unreffed,\n        cloneDeepUnref(arg2) as QueryFilters,\n      )\n    }\n    return super.removeQueries(arg1Unreffed as QueryFilters)\n  }\n\n  resetQueries<TPageData = unknown>(\n    filters?: MaybeRefDeep<ResetQueryFilters<TPageData>>,\n    options?: MaybeRefDeep<ResetOptions>,\n  ): Promise<void>\n  resetQueries<TPageData = unknown>(\n    queryKey?: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<ResetQueryFilters<TPageData>>,\n    options?: MaybeRefDeep<ResetOptions>,\n  ): Promise<void>\n  resetQueries<TPageData = unknown>(\n    arg1?: MaybeRefDeep<QueryKey | ResetQueryFilters<TPageData>>,\n    arg2?: MaybeRefDeep<ResetQueryFilters<TPageData> | ResetOptions>,\n    arg3?: MaybeRefDeep<ResetOptions>,\n  ): Promise<void> {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2)\n    if (isQueryKey(arg1Unreffed)) {\n      return super.resetQueries(\n        arg1Unreffed,\n        arg2Unreffed as ResetQueryFilters<TPageData> | undefined,\n        cloneDeepUnref(arg3) as ResetOptions,\n      )\n    }\n    return super.resetQueries(\n      arg1Unreffed as ResetQueryFilters<TPageData>,\n      arg2Unreffed as ResetOptions,\n    )\n  }\n\n  cancelQueries(\n    filters?: MaybeRefDeep<QueryFilters>,\n    options?: MaybeRefDeep<CancelOptions>,\n  ): Promise<void>\n  cancelQueries(\n    queryKey?: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<QueryFilters>,\n    options?: MaybeRefDeep<CancelOptions>,\n  ): Promise<void>\n  cancelQueries(\n    arg1?: MaybeRefDeep<QueryKey | QueryFilters>,\n    arg2?: MaybeRefDeep<QueryFilters | CancelOptions>,\n    arg3?: MaybeRefDeep<CancelOptions>,\n  ): Promise<void> {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2)\n    if (isQueryKey(arg1Unreffed)) {\n      return super.cancelQueries(\n        arg1Unreffed,\n        arg2Unreffed as QueryFilters | undefined,\n        cloneDeepUnref(arg3) as CancelOptions,\n      )\n    }\n    return super.cancelQueries(\n      arg1Unreffed as QueryFilters,\n      arg2Unreffed as CancelOptions,\n    )\n  }\n\n  invalidateQueries<TPageData = unknown>(\n    filters?: MaybeRefDeep<InvalidateQueryFilters<TPageData>>,\n    options?: MaybeRefDeep<InvalidateOptions>,\n  ): Promise<void>\n  invalidateQueries<TPageData = unknown>(\n    queryKey?: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<InvalidateQueryFilters<TPageData>>,\n    options?: MaybeRefDeep<InvalidateOptions>,\n  ): Promise<void>\n  invalidateQueries<TPageData = unknown>(\n    arg1?: MaybeRefDeep<QueryKey | InvalidateQueryFilters<TPageData>>,\n    arg2?: MaybeRefDeep<InvalidateQueryFilters<TPageData> | InvalidateOptions>,\n    arg3?: MaybeRefDeep<InvalidateOptions>,\n  ): Promise<void> {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2)\n    if (isQueryKey(arg1Unreffed)) {\n      return super.invalidateQueries(\n        arg1Unreffed,\n        arg2Unreffed as InvalidateQueryFilters | undefined,\n        cloneDeepUnref(arg3) as InvalidateOptions,\n      )\n    }\n    return super.invalidateQueries(\n      arg1Unreffed as InvalidateQueryFilters<TPageData>,\n      arg2Unreffed as InvalidateOptions,\n    )\n  }\n\n  refetchQueries<TPageData = unknown>(\n    filters?: MaybeRefDeep<RefetchQueryFilters<TPageData>>,\n    options?: MaybeRefDeep<RefetchOptions>,\n  ): Promise<void>\n  refetchQueries<TPageData = unknown>(\n    queryKey?: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<RefetchQueryFilters<TPageData>>,\n    options?: MaybeRefDeep<RefetchOptions>,\n  ): Promise<void>\n  refetchQueries<TPageData = unknown>(\n    arg1?: MaybeRefDeep<QueryKey | RefetchQueryFilters<TPageData>>,\n    arg2?: MaybeRefDeep<RefetchQueryFilters<TPageData> | RefetchOptions>,\n    arg3?: MaybeRefDeep<RefetchOptions>,\n  ): Promise<void> {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2)\n    if (isQueryKey(arg1Unreffed)) {\n      return super.refetchQueries(\n        arg1Unreffed,\n        arg2Unreffed as RefetchQueryFilters | undefined,\n        cloneDeepUnref(arg3) as RefetchOptions,\n      )\n    }\n    return super.refetchQueries(\n      arg1Unreffed as RefetchQueryFilters<TPageData>,\n      arg2Unreffed as RefetchOptions,\n    )\n  }\n\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | MaybeRefDeep<TQueryKey>\n      | MaybeRefDeep<FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | MaybeRefDeep<FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>>,\n    arg3?: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<TData> {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2)\n    if (isQueryKey(arg1Unreffed)) {\n      return super.fetchQuery(\n        arg1Unreffed as TQueryKey,\n        arg2Unreffed as QueryFunction<TQueryFnData, TQueryKey>,\n        cloneDeepUnref(arg3) as FetchQueryOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryKey\n        >,\n      )\n    }\n    return super.fetchQuery(\n      arg1Unreffed as FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    )\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: MaybeRefDeep<\n      TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | MaybeRefDeep<FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>>,\n    arg3?: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void> {\n    return super.prefetchQuery(\n      cloneDeepUnref(arg1) as any,\n      cloneDeepUnref(arg2) as any,\n      cloneDeepUnref(arg3) as any,\n    )\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: MaybeRefDeep<\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | MaybeRefDeep<\n          FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n        >,\n    arg3?: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<InfiniteData<TData>> {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2)\n    if (isQueryKey(arg1Unreffed)) {\n      return super.fetchInfiniteQuery(\n        arg1Unreffed as TQueryKey,\n        arg2Unreffed as QueryFunction<TQueryFnData, TQueryKey>,\n        cloneDeepUnref(arg3) as FetchInfiniteQueryOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryKey\n        >,\n      )\n    }\n    return super.fetchInfiniteQuery(\n      arg1Unreffed as FetchInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryKey\n      >,\n    )\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: MaybeRefDeep<\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | MaybeRefDeep<\n          FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n        >,\n    arg3?: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void> {\n    return super.prefetchInfiniteQuery(\n      cloneDeepUnref(arg1) as any,\n      cloneDeepUnref(arg2) as any,\n      cloneDeepUnref(arg3) as any,\n    )\n  }\n\n  setDefaultOptions(options: MaybeRefDeep<DefaultOptions>): void {\n    super.setDefaultOptions(cloneDeepUnref(options) as DefaultOptions)\n  }\n\n  setQueryDefaults(\n    queryKey: MaybeRefDeep<QueryKey>,\n    options: MaybeRefDeep<QueryObserverOptions<any, any, any, any>>,\n  ): void {\n    super.setQueryDefaults(\n      cloneDeepUnref(queryKey),\n      cloneDeepUnref(options) as any,\n    )\n  }\n\n  getQueryDefaults(\n    queryKey?: MaybeRefDeep<QueryKey>,\n  ): QueryObserverOptions<any, any, any, any, any> | undefined {\n    return super.getQueryDefaults(cloneDeepUnref(queryKey))\n  }\n\n  setMutationDefaults(\n    mutationKey: MaybeRefDeep<MutationKey>,\n    options: MaybeRefDeep<MutationObserverOptions<any, any, any, any>>,\n  ): void {\n    super.setMutationDefaults(\n      cloneDeepUnref(mutationKey),\n      cloneDeepUnref(options) as any,\n    )\n  }\n\n  getMutationDefaults(\n    mutationKey?: MaybeRefDeep<MutationKey>,\n  ): MutationObserverOptions<any, any, any, any> | undefined {\n    return super.getMutationDefaults(cloneDeepUnref(mutationKey))\n  }\n}\n","import { parseFilterArgs, functionalUpdate, parseQueryArgs, noop, hashQueryKey, partialMatchKey, hashQueryKeyByOptions } from './utils.mjs';\nimport { QueryCache } from './queryCache.mjs';\nimport { MutationCache } from './mutationCache.mjs';\nimport { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior.mjs';\nimport { defaultLogger } from './logger.mjs';\n\n// CLASS\nclass QueryClient {\n  constructor(config = {}) {\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n  }\n\n  mount() {\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.queryCache.onFocus();\n      }\n    });\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.queryCache.onOnline();\n      }\n    });\n  }\n\n  unmount() {\n    var _this$unsubscribeFocu, _this$unsubscribeOnli;\n\n    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n  }\n\n  isFetching(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    filters.fetchStatus = 'fetching';\n    return this.queryCache.findAll(filters).length;\n  }\n\n  isMutating(filters) {\n    return this.mutationCache.findAll({ ...filters,\n      fetching: true\n    }).length;\n  }\n\n  getQueryData(queryKey, filters) {\n    var _this$queryCache$find;\n\n    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n  }\n\n  getQueriesData(queryKeyOrFilters) {\n    return this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey,\n      state\n    }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n\n  setQueryData(queryKey, updater, options) {\n    const query = this.queryCache.find(queryKey);\n    const prevData = query == null ? void 0 : query.state.data;\n    const data = functionalUpdate(updater, prevData);\n\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions);\n    return this.queryCache.build(this, defaultedOptions).setData(data, { ...options,\n      manual: true\n    });\n  }\n\n  setQueriesData(queryKeyOrFilters, updater, options) {\n    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey\n    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));\n  }\n\n  getQueryState(queryKey, filters) {\n    var _this$queryCache$find2;\n\n    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n  }\n\n  removeQueries(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    const queryCache = this.queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n\n  resetQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const queryCache = this.queryCache;\n    const refetchFilters = {\n      type: 'active',\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  cancelQueries(arg1, arg2, arg3) {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true;\n    }\n\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n\n  invalidateQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    return notifyManager.batch(() => {\n      var _ref, _filters$refetchType;\n\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve();\n      }\n\n      const refetchFilters = { ...filters,\n        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  refetchQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      var _options$cancelRefetc;\n\n      return query.fetch(undefined, { ...options,\n        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n        meta: {\n          refetchPage: filters.refetchPage\n        }\n      });\n    }));\n    let promise = Promise.all(promises).then(noop);\n\n    if (!(options != null && options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  fetchQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false;\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n\n  prefetchQuery(arg1, arg2, arg3) {\n    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  fetchInfiniteQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    parsedOptions.behavior = infiniteQueryBehavior();\n    return this.fetchQuery(parsedOptions);\n  }\n\n  prefetchInfiniteQuery(arg1, arg2, arg3) {\n    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  resumePausedMutations() {\n    return this.mutationCache.resumePausedMutations();\n  }\n\n  getQueryCache() {\n    return this.queryCache;\n  }\n\n  getMutationCache() {\n    return this.mutationCache;\n  }\n\n  getLogger() {\n    return this.logger;\n  }\n\n  getDefaultOptions() {\n    return this.defaultOptions;\n  }\n\n  setDefaultOptions(options) {\n    this.defaultOptions = options;\n  }\n\n  setQueryDefaults(queryKey, options) {\n    const result = this.queryDefaults.find(x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.queryDefaults.push({\n        queryKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getQueryDefaults(queryKey) {\n    if (!queryKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter(x => partialMatchKey(queryKey, x.queryKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  setMutationDefaults(mutationKey, options) {\n    const result = this.mutationDefaults.find(x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.mutationDefaults.push({\n        mutationKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getMutationDefaults(mutationKey) {\n    if (!mutationKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.mutationDefaults.find(x => partialMatchKey(mutationKey, x.mutationKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter(x => partialMatchKey(mutationKey, x.mutationKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  defaultQueryOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    const defaultedOptions = { ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    } // dependent default values\n\n\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n    }\n\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n    }\n\n    return defaultedOptions;\n  }\n\n  defaultMutationOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    return { ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n\n  clear() {\n    this.queryCache.clear();\n    this.mutationCache.clear();\n  }\n\n}\n\nexport { QueryClient };\n//# sourceMappingURL=queryClient.mjs.map\n","import { isVue2 } from 'vue-demi'\nimport type { QueryClientConfig } from '@tanstack/query-core'\n\nimport { QueryClient } from './queryClient'\nimport { getClientKey } from './utils'\nimport { setupDevtools } from './devtools/devtools'\nimport type { MaybeRefDeep } from './types'\n\ndeclare global {\n  interface Window {\n    __VUE_QUERY_CONTEXT__?: QueryClient\n  }\n}\n\nexport interface AdditionalClient {\n  queryClient: QueryClient\n  queryClientKey: string\n}\n\ninterface ConfigOptions {\n  queryClientConfig?: MaybeRefDeep<QueryClientConfig>\n  queryClientKey?: string\n  contextSharing?: boolean\n}\n\ninterface ClientOptions {\n  queryClient?: QueryClient\n  queryClientKey?: string\n  contextSharing?: boolean\n}\n\nexport type VueQueryPluginOptions = ConfigOptions | ClientOptions\n\nexport const VueQueryPlugin = {\n  install: (app: any, options: VueQueryPluginOptions = {}) => {\n    const clientKey = getClientKey(options.queryClientKey)\n    let client: QueryClient\n\n    if ('queryClient' in options && options.queryClient) {\n      client = options.queryClient\n    } else {\n      if (options.contextSharing && typeof window !== 'undefined') {\n        if (!window.__VUE_QUERY_CONTEXT__) {\n          const clientConfig =\n            'queryClientConfig' in options\n              ? options.queryClientConfig\n              : undefined\n          client = new QueryClient(clientConfig)\n          window.__VUE_QUERY_CONTEXT__ = client\n        } else {\n          client = window.__VUE_QUERY_CONTEXT__\n        }\n      } else {\n        const clientConfig =\n          'queryClientConfig' in options ? options.queryClientConfig : undefined\n        client = new QueryClient(clientConfig)\n      }\n    }\n\n    client.mount()\n\n    const cleanup = () => {\n      client.unmount()\n    }\n\n    if (app.onUnmount) {\n      app.onUnmount(cleanup)\n    } else {\n      const originalUnmount = app.unmount\n      app.unmount = function vueQueryUnmount() {\n        cleanup()\n        originalUnmount()\n      }\n    }\n\n    /* istanbul ignore next */\n    if (isVue2) {\n      app.mixin({\n        beforeCreate() {\n          // HACK: taken from provide(): https://github.com/vuejs/composition-api/blob/master/src/apis/inject.ts#L30\n          if (!this._provided) {\n            const provideCache = {}\n            Object.defineProperty(this, '_provided', {\n              get: () => provideCache,\n              set: (v) => Object.assign(provideCache, v),\n            })\n          }\n\n          this._provided[clientKey] = client\n\n          if (process.env.NODE_ENV === 'development') {\n            if (this === this.$root) {\n              setupDevtools(this, client)\n            }\n          }\n        },\n      })\n    } else {\n      app.provide(clientKey, client)\n\n      if (process.env.NODE_ENV === 'development') {\n        setupDevtools(app, client)\n      }\n    }\n  },\n}\n","import { onScopeDispose, toRefs, readonly, reactive, watch } from 'vue-demi'\nimport type { ToRefs, UnwrapRef } from 'vue-demi'\nimport type {\n  QueryObserver,\n  QueryKey,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryFunction,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './useQueryClient'\nimport { updateState, isQueryKey, cloneDeepUnref } from './utils'\nimport type { WithQueryClientKey } from './types'\nimport type { UseQueryOptions } from './useQuery'\nimport type { UseInfiniteQueryOptions } from './useInfiniteQuery'\n\nexport type UseQueryReturnType<\n  TData,\n  TError,\n  Result = QueryObserverResult<TData, TError>,\n> = ToRefs<Readonly<Result>> & {\n  suspense: () => Promise<Result>\n}\n\ntype UseQueryOptionsGeneric<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  | UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  Observer: typeof QueryObserver,\n  arg1:\n    | TQueryKey\n    | UseQueryOptionsGeneric<TQueryFnData, TError, TData, TQueryKey>,\n  arg2:\n    | QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>\n    | UseQueryOptionsGeneric<TQueryFnData, TError, TData, TQueryKey> = {},\n  arg3: UseQueryOptionsGeneric<TQueryFnData, TError, TData, TQueryKey> = {},\n): UseQueryReturnType<TData, TError> {\n  const options = getQueryUnreffedOptions()\n  const queryClient =\n    options.queryClient ?? useQueryClient(options.queryClientKey)\n  const defaultedOptions = queryClient.defaultQueryOptions(options)\n  const observer = new Observer(queryClient, defaultedOptions)\n  const state = reactive(observer.getCurrentResult())\n  const unsubscribe = observer.subscribe((result) => {\n    updateState(state, result)\n  })\n\n  watch(\n    [() => arg1, () => arg2, () => arg3],\n    () => {\n      observer.setOptions(\n        queryClient.defaultQueryOptions(getQueryUnreffedOptions()),\n      )\n    },\n    { deep: true },\n  )\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  const suspense = () => {\n    return new Promise<QueryObserverResult<TData, TError>>((resolve) => {\n      const run = () => {\n        const newOptions = queryClient.defaultQueryOptions(\n          getQueryUnreffedOptions(),\n        )\n        if (newOptions.enabled !== false) {\n          const optimisticResult = observer.getOptimisticResult(newOptions)\n          if (optimisticResult.isStale) {\n            resolve(observer.fetchOptimistic(defaultedOptions))\n          } else {\n            resolve(optimisticResult)\n          }\n        }\n      }\n\n      run()\n\n      watch([() => arg1, () => arg2, () => arg3], run, { deep: true })\n    })\n  }\n\n  return {\n    ...(toRefs(readonly(state)) as UseQueryReturnType<TData, TError>),\n    suspense,\n  }\n\n  /**\n   * Get Query Options object\n   * All inner refs unwrapped. No Reactivity\n   */\n  function getQueryUnreffedOptions() {\n    let mergedOptions\n\n    if (!isQueryKey(arg1)) {\n      // `useQuery(optionsObj)`\n      mergedOptions = arg1\n    } else if (typeof arg2 === 'function') {\n      // `useQuery(queryKey, queryFn, optionsObj?)`\n      mergedOptions = { ...arg3, queryKey: arg1, queryFn: arg2 }\n    } else {\n      // `useQuery(queryKey, optionsObj?)`\n      mergedOptions = { ...arg2, queryKey: arg1 }\n    }\n\n    return cloneDeepUnref(mergedOptions) as WithQueryClientKey<\n      QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n    >\n  }\n}\n","import { onScopeDispose, ref, watch } from 'vue-demi'\nimport type { Ref } from 'vue-demi'\nimport type { QueryKey, QueryFilters as QF } from '@tanstack/query-core'\n\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref, isQueryKey } from './utils'\nimport type { MaybeRefDeep, WithQueryClientKey } from './types'\n\nexport type QueryFilters = MaybeRefDeep<WithQueryClientKey<QF>>\n\nexport function useIsFetching(filters?: QueryFilters): Ref<number>\nexport function useIsFetching(\n  queryKey?: QueryKey,\n  filters?: QueryFilters,\n): Ref<number>\nexport function useIsFetching(\n  arg1?: QueryKey | QueryFilters,\n  arg2?: QueryFilters,\n): Ref<number> {\n  const filters = ref(parseFilterArgs(arg1, arg2))\n  const queryClient =\n    filters.value.queryClient ?? useQueryClient(filters.value.queryClientKey)\n\n  const isFetching = ref(queryClient.isFetching(filters))\n\n  const unsubscribe = queryClient.getQueryCache().subscribe(() => {\n    isFetching.value = queryClient.isFetching(filters)\n  })\n\n  watch(\n    [() => arg1, () => arg2],\n    () => {\n      filters.value = parseFilterArgs(arg1, arg2)\n      isFetching.value = queryClient.isFetching(filters)\n    },\n    { deep: true },\n  )\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return isFetching\n}\n\nexport function parseFilterArgs(\n  arg1?: QueryKey | QueryFilters,\n  arg2: QueryFilters = {},\n) {\n  let options: QueryFilters\n\n  if (isQueryKey(arg1)) {\n    options = { ...arg2, queryKey: arg1 }\n  } else {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    options = arg1 || {}\n  }\n\n  return cloneDeepUnref(options) as WithQueryClientKey<QF>\n}\n","import { onScopeDispose, ref, watch } from 'vue-demi'\nimport type { Ref } from 'vue-demi'\nimport type { MutationKey, MutationFilters as MF } from '@tanstack/query-core'\n\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref, isQueryKey } from './utils'\nimport type { MaybeRefDeep, WithQueryClientKey } from './types'\n\nexport type MutationFilters = MaybeRefDeep<WithQueryClientKey<MF>>\n\nexport function useIsMutating(filters?: MutationFilters): Ref<number>\nexport function useIsMutating(\n  mutationKey?: MutationKey,\n  filters?: Omit<MutationFilters, 'mutationKey'>,\n): Ref<number>\nexport function useIsMutating(\n  arg1?: MutationKey | MutationFilters,\n  arg2?: Omit<MutationFilters, 'mutationKey'>,\n): Ref<number> {\n  const filters = ref(parseMutationFilterArgs(arg1, arg2))\n  const queryClient =\n    filters.value.queryClient ?? useQueryClient(filters.value.queryClientKey)\n\n  const isMutating = ref(queryClient.isMutating(filters))\n\n  const unsubscribe = queryClient.getMutationCache().subscribe(() => {\n    isMutating.value = queryClient.isMutating(filters)\n  })\n\n  watch(\n    [() => arg1, () => arg2],\n    () => {\n      filters.value = parseMutationFilterArgs(arg1, arg2)\n      isMutating.value = queryClient.isMutating(filters)\n    },\n    { deep: true },\n  )\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return isMutating\n}\n\nexport function parseMutationFilterArgs(\n  arg1?: MutationKey | MutationFilters,\n  arg2: MutationFilters = {},\n) {\n  let options: MutationFilters\n\n  if (isQueryKey(arg1)) {\n    options = { ...arg2, mutationKey: arg1 }\n  } else {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    options = arg1 || {}\n  }\n\n  return cloneDeepUnref(options) as WithQueryClientKey<MF>\n}\n","import { InfiniteQueryObserver } from '@tanstack/query-core'\nimport type { UnwrapRef } from 'vue-demi'\nimport type {\n  QueryObserver,\n  QueryFunction,\n  QueryKey,\n  InfiniteQueryObserverResult,\n} from '@tanstack/query-core'\n\nimport { useBaseQuery } from './useBaseQuery'\nimport type { UseQueryReturnType } from './useBaseQuery'\n\nimport type {\n  WithQueryClientKey,\n  VueInfiniteQueryObserverOptions,\n} from './types'\n\nexport type UseInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = WithQueryClientKey<\n  VueInfiniteQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >\n>\n\ntype InfiniteQueryReturnType<TData, TError> = UseQueryReturnType<\n  TData,\n  TError,\n  InfiniteQueryObserverResult<TData, TError>\n>\ntype UseInfiniteQueryReturnType<TData, TError> = Omit<\n  InfiniteQueryReturnType<TData, TError>,\n  'fetchNextPage' | 'fetchPreviousPage' | 'refetch' | 'remove'\n> & {\n  fetchNextPage: InfiniteQueryObserverResult<TData, TError>['fetchNextPage']\n  fetchPreviousPage: InfiniteQueryObserverResult<\n    TData,\n    TError\n  >['fetchPreviousPage']\n  refetch: InfiniteQueryObserverResult<TData, TError>['refetch']\n  remove: InfiniteQueryObserverResult<TData, TError>['remove']\n}\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseInfiniteQueryReturnType<TData, TError>\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey'\n  >,\n): UseInfiniteQueryReturnType<TData, TError>\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>,\n  options?: Omit<\n    UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn'\n  >,\n): UseInfiniteQueryReturnType<TData, TError>\n\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1:\n    | TQueryKey\n    | UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg2?:\n    | QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>\n    | UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg3?: UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseInfiniteQueryReturnType<TData, TError> {\n  const result = useBaseQuery(\n    InfiniteQueryObserver as typeof QueryObserver,\n    arg1,\n    arg2,\n    arg3,\n  ) as InfiniteQueryReturnType<TData, TError>\n  return {\n    ...result,\n    fetchNextPage: result.fetchNextPage.value,\n    fetchPreviousPage: result.fetchPreviousPage.value,\n    refetch: result.refetch.value,\n    remove: result.remove.value,\n  }\n}\n","import {\n  onScopeDispose,\n  reactive,\n  readonly,\n  toRefs,\n  watch,\n  computed,\n  isRef,\n} from 'vue-demi'\nimport type { ToRefs } from 'vue-demi'\nimport type {\n  MutateOptions,\n  MutationFunction,\n  MutationKey,\n  MutateFunction,\n  MutationObserverResult,\n  MutationObserverOptions,\n} from '@tanstack/query-core'\nimport type { WithQueryClientKey, MaybeRef, MaybeRefDeep } from './types'\nimport { MutationObserver } from '@tanstack/query-core'\nimport { cloneDeepUnref, updateState, isMutationKey } from './utils'\nimport { useQueryClient } from './useQueryClient'\n\ntype MutationResult<TData, TError, TVariables, TContext> = Omit<\n  MutationObserverResult<TData, TError, TVariables, TContext>,\n  'mutate' | 'reset'\n>\n\nexport type UseMutationOptions<TData, TError, TVariables, TContext> =\n  WithQueryClientKey<\n    MutationObserverOptions<TData, TError, TVariables, TContext>\n  >\n\nexport type VueMutationObserverOptions<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> = {\n  [Property in keyof UseMutationOptions<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >]: MaybeRefDeep<\n    UseMutationOptions<TData, TError, TVariables, TContext>[Property]\n  >\n}\n\ntype MutateSyncFunction<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> = (\n  ...options: Parameters<MutateFunction<TData, TError, TVariables, TContext>>\n) => void\n\nexport type UseMutationReturnType<\n  TData,\n  TError,\n  TVariables,\n  TContext,\n  Result = MutationResult<TData, TError, TVariables, TContext>,\n> = ToRefs<Readonly<Result>> & {\n  mutate: MutateSyncFunction<TData, TError, TVariables, TContext>\n  mutateAsync: MutateFunction<TData, TError, TVariables, TContext>\n  reset: MutationObserverResult<TData, TError, TVariables, TContext>['reset']\n}\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: MaybeRef<\n    VueMutationObserverOptions<TData, TError, TVariables, TContext>\n  >,\n): UseMutationReturnType<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationFn: MaybeRef<MutationFunction<TData, TVariables>>,\n  options?: MaybeRef<\n    Omit<\n      VueMutationObserverOptions<TData, TError, TVariables, TContext>,\n      'mutationFn'\n    >\n  >,\n): UseMutationReturnType<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MaybeRef<MutationKey>,\n  options?: MaybeRef<\n    Omit<\n      VueMutationObserverOptions<TData, TError, TVariables, TContext>,\n      'mutationKey'\n    >\n  >,\n): UseMutationReturnType<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MaybeRef<MutationKey>,\n  mutationFn?: MaybeRef<MutationFunction<TData, TVariables>>,\n  options?: MaybeRef<\n    Omit<\n      VueMutationObserverOptions<TData, TError, TVariables, TContext>,\n      'mutationKey' | 'mutationFn'\n    >\n  >,\n): UseMutationReturnType<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MaybeRef<MutationKey>\n    | MaybeRef<MutationFunction<TData, TVariables>>\n    | MaybeRef<VueMutationObserverOptions<TData, TError, TVariables, TContext>>,\n  arg2?:\n    | MaybeRef<MutationFunction<TData, TVariables>>\n    | MaybeRef<VueMutationObserverOptions<TData, TError, TVariables, TContext>>,\n  arg3?: MaybeRef<\n    VueMutationObserverOptions<TData, TError, TVariables, TContext>\n  >,\n): UseMutationReturnType<TData, TError, TVariables, TContext> {\n  const options = computed(() => {\n    return parseMutationArgs(arg1, arg2, arg3)\n  })\n  const queryClient =\n    options.value.queryClient ?? useQueryClient(options.value.queryClientKey)\n  const observer = new MutationObserver(\n    queryClient,\n    queryClient.defaultMutationOptions(options.value),\n  )\n  const state = reactive(observer.getCurrentResult())\n\n  const unsubscribe = observer.subscribe((result) => {\n    updateState(state, result)\n  })\n\n  const mutate = (\n    variables: TVariables,\n    mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>,\n  ) => {\n    observer.mutate(variables, mutateOptions).catch(() => {\n      // This is intentional\n    })\n  }\n\n  watch(\n    options,\n    () => {\n      observer.setOptions(queryClient.defaultMutationOptions(options.value))\n    },\n    { deep: true },\n  )\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  const resultRefs = toRefs(readonly(state)) as unknown as ToRefs<\n    Readonly<MutationResult<TData, TError, TVariables, TContext>>\n  >\n\n  return {\n    ...resultRefs,\n    mutate,\n    mutateAsync: state.mutate,\n    reset: state.reset,\n  }\n}\n\nexport function parseMutationArgs<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MaybeRef<MutationKey>\n    | MaybeRef<MutationFunction<TData, TVariables>>\n    | MaybeRef<VueMutationObserverOptions<TData, TError, TVariables, TContext>>,\n  arg2?:\n    | MaybeRef<MutationFunction<TData, TVariables>>\n    | MaybeRef<VueMutationObserverOptions<TData, TError, TVariables, TContext>>,\n  arg3?: MaybeRef<\n    VueMutationObserverOptions<TData, TError, TVariables, TContext>\n  >,\n): WithQueryClientKey<\n  MutationObserverOptions<TData, TError, TVariables, TContext>\n> {\n  const plainArg1 = isRef(arg1) ? arg1.value : arg1\n  const plainArg2 = isRef(arg2) ? arg2.value : arg2\n  let options = plainArg1\n  if (isMutationKey(plainArg1)) {\n    if (typeof plainArg2 === 'function') {\n      const plainArg3 = isRef(arg3) ? arg3.value : arg3\n      options = { ...plainArg3, mutationKey: plainArg1, mutationFn: plainArg2 }\n    } else {\n      options = { ...plainArg2, mutationKey: plainArg1 }\n    }\n  }\n\n  if (typeof plainArg1 === 'function') {\n    options = { ...plainArg2, mutationFn: plainArg1 }\n  }\n\n  return cloneDeepUnref(options) as UseMutationOptions<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { QueriesObserver } from '@tanstack/query-core'\nimport { onScopeDispose, reactive, readonly, watch } from 'vue-demi'\nimport type { Ref } from 'vue-demi'\n\nimport type { QueryFunction, QueryObserverResult } from '@tanstack/query-core'\n\nimport { useQueryClient } from './useQueryClient'\nimport type { UseQueryOptions } from './useQuery'\nimport { cloneDeepUnref } from './utils'\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptions<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptions<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptions<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptions<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptions<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptions<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryOptions<TQueryFnData, unknown, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? UseQueryOptions<TQueryFnData, unknown, TQueryFnData, TQueryKey>\n    : // Fallback\n      UseQueryOptions\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? QueryObserverResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? QueryObserverResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? QueryObserverResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? QueryObserverResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? QueryObserverResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? QueryObserverResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? QueryObserverResult<TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? QueryObserverResult<TQueryFnData>\n    : // Fallback\n      QueryObserverResult\n\n/**\n * UseQueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type UseQueriesOptions<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryOptions[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? UseQueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends UseQueryOptions<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    UseQueryOptions[]\n\n/**\n * UseQueriesResults reducer recursively maps type param to results\n */\nexport type UseQueriesResults<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? QueryObserverResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? UseQueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends UseQueryOptions<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    QueryObserverResult<unknown extends TData ? TQueryFnData : TData, TError>[]\n  : // Fallback\n    QueryObserverResult[]\n\ntype UseQueriesOptionsArg<T extends any[]> = readonly [...UseQueriesOptions<T>]\n\nexport function useQueries<T extends any[]>({\n  queries,\n}: {\n  queries: Ref<UseQueriesOptionsArg<T>> | UseQueriesOptionsArg<T>\n}): Readonly<UseQueriesResults<T>> {\n  const unreffedQueries = cloneDeepUnref(queries) as UseQueriesOptionsArg<T>\n\n  const queryClientKey = unreffedQueries[0].queryClientKey\n  const optionsQueryClient = unreffedQueries[0].queryClient\n  const queryClient = optionsQueryClient ?? useQueryClient(queryClientKey)\n  const defaultedQueries = unreffedQueries.map((options) => {\n    return queryClient.defaultQueryOptions(options)\n  })\n\n  const observer = new QueriesObserver(queryClient, defaultedQueries)\n  const state = reactive(observer.getCurrentResult())\n\n  const unsubscribe = observer.subscribe((result) => {\n    state.splice(0, state.length, ...result)\n  })\n\n  watch(\n    () => queries,\n    () => {\n      const defaulted = (\n        cloneDeepUnref(queries) as UseQueriesOptionsArg<T>\n      ).map((options) => {\n        return queryClient.defaultQueryOptions(options)\n      })\n      observer.setQueries(defaulted)\n    },\n    { deep: true },\n  )\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return readonly(state) as UseQueriesResults<T>\n}\n","import type { ToRefs, UnwrapRef } from 'vue-demi'\nimport { QueryObserver } from '@tanstack/query-core'\nimport type {\n  QueryFunction,\n  QueryKey,\n  QueryObserverResult,\n  DefinedQueryObserverResult,\n} from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type { UseQueryReturnType as UQRT } from './useBaseQuery'\nimport type { WithQueryClientKey, VueQueryObserverOptions } from './types'\n\ntype UseQueryReturnType<TData, TError> = Omit<\n  UQRT<TData, TError>,\n  'refetch' | 'remove'\n> & {\n  refetch: QueryObserverResult<TData, TError>['refetch']\n  remove: QueryObserverResult<TData, TError>['remove']\n}\n\ntype UseQueryDefinedReturnType<TData, TError> = Omit<\n  ToRefs<Readonly<DefinedQueryObserverResult<TData, TError>>>,\n  'refetch' | 'remove'\n> & {\n  suspense: () => Promise<QueryObserverResult<TData, TError>>\n  refetch: QueryObserverResult<TData, TError>['refetch']\n  remove: QueryObserverResult<TData, TError>['remove']\n}\n\nexport type UseQueryOptions<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = WithQueryClientKey<\n  VueQueryObserverOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>\n>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): UseQueryDefinedReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): UseQueryDefinedReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey'\n  >,\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): UseQueryDefinedReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn'\n  >,\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg2?:\n    | QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>\n    | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg3?: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n):\n  | UseQueryReturnType<TData, TError>\n  | UseQueryDefinedReturnType<TData, TError> {\n  const result = useBaseQuery(QueryObserver, arg1, arg2, arg3)\n\n  return {\n    ...result,\n    refetch: result.refetch.value,\n    remove: result.remove.value,\n  }\n}\n"],"names":["Subscribable","constructor","this","listeners","subscribe","bind","listener","push","onSubscribe","filter","x","onUnsubscribe","hasListeners","length","isServer","window","noop","isValidTimeout","value","Infinity","difference","array1","array2","indexOf","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","parseQueryArgs","arg1","arg2","arg3","isQueryKey","queryKey","queryFn","parseFilterArgs","matchQuery","filters","query","type","exact","fetchStatus","predicate","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isActive","isStale","state","matchMutation","mutation","fetching","mutationKey","hashQueryKey","status","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","Object","keys","sort","reduce","result","key","a","b","partialDeepEqual","some","replaceEqualDeep","array","isPlainArray","aSize","bItems","bSize","copy","equalItems","i","shallowEqualObjects","Array","isArray","o","hasObjectPrototype","ctor","prot","prototype","hasOwnProperty","toString","call","sleep","timeout","Promise","resolve","setTimeout","scheduleMicrotask","callback","then","replaceData","prevData","data","isDataEqual","structuralSharing","focusManager","super","setup","onFocus","addEventListener","removeEventListener","cleanup","setEventListener","_this$cleanup","undefined","_this$cleanup2","focused","setFocused","forEach","isFocused","document","includes","visibilityState","onlineManager","onOnline","online","setOnline","isOnline","navigator","onLine","defaultRetryDelay","failureCount","min","canFetch","networkMode","CancelledError","revert","silent","isCancelledError","createRetryer","config","continueFn","promiseResolve","promiseReject","isRetryCancelled","isResolved","promise","outerResolve","outerReject","shouldPause","onSuccess","reject","onError","pause","continueResolve","onPause","onContinue","run","promiseOrValue","fn","error","catch","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","onFail","cancel","cancelOptions","abort","continue","cancelRetry","continueRetry","defaultLogger","console","notifyManager","queue","transactions","notifyFn","batchNotifyFn","schedule","flush","originalQueue","batch","batchCalls","args","setNotifyFunction","setBatchNotifyFunction","createNotifyManager","Removable","destroy","clearGcTimeout","scheduleGc","cacheTime","gcTimeout","optionalRemove","updateCacheTime","newCacheTime","clearTimeout","Query","abortSignalConsumed","defaultOptions","setOptions","observers","cache","logger","initialState","initialData","initialDataUpdatedAt","hasData","dataUpdateCount","dataUpdatedAt","errorUpdateCount","errorUpdatedAt","fetchFailureCount","fetchFailureReason","fetchMeta","isInvalidated","getDefaultState","meta","remove","setData","newData","dispatch","manual","setState","setStateOptions","_this$retryer","retryer","reset","observer","enabled","isDisabled","getObserversCount","getCurrentResult","isStaleByTime","_this$retryer2","find","shouldFetchOnWindowFocus","refetch","cancelRefetch","_this$retryer3","shouldFetchOnReconnect","addObserver","notify","removeObserver","invalidate","fetch","fetchOptions","_this$options$behavio","_context$fetchOptions","_this$retryer4","abortController","AbortController","getAbortController","queryFnContext","pageParam","addSignalProperty","object","defineProperty","enumerable","get","signal","context","fetchFn","_context$fetchOptions2","behavior","onFetch","revertState","_this$cache$config$on","_this$cache$config","isFetchingOptimistic","_this$cache$config$on2","_this$cache$config2","Error","action","_action$meta","_action$dataUpdatedAt","reducer","onQueryUpdate","QueryCache","queries","queriesMap","build","client","_options$queryHash","getLogger","defaultQueryOptions","getQueryDefaults","add","queryInMap","clear","getAll","findAll","event","Mutation","mutationId","mutationCache","execute","async","executeMutation","_this$options$retry","mutationFn","variables","restored","_this$mutationCache$c3","_this$mutationCache$c4","_this$options$onSucce","_this$options2","_this$options$onSettl","_this$options3","_this$mutationCache$c","_this$mutationCache$c2","_this$options$onMutat","_this$options","onMutate","onSettled","_this$mutationCache$c5","_this$mutationCache$c6","_this$options$onError","_this$options4","_this$options$onSettl2","_this$options5","failureReason","isPaused","onMutationUpdate","MutationCache","mutations","defaultMutationOptions","getMutationDefaults","resumePausedMutations","pausedMutations","infiniteQueryBehavior","_context$fetchOptions3","_context$fetchOptions4","_context$state$data","_context$state$data2","refetchPage","fetchMore","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","pages","oldPageParams","pageParams","newPageParams","cancelled","buildNewPages","param","page","previous","fetchPage","_context$signal","_context$signal2","aborted","queryFnResult","getNextPageParam","getPreviousPageParam","hasNextPage","nextPageParam","hasPreviousPage","previousPageParam","QueryObserver","trackedProps","Set","selectError","bindMethods","currentQuery","shouldFetchOnMount","executeFetch","updateTimers","shouldFetchOn","refetchOnReconnect","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","notifyOptions","prevOptions","prevQuery","getQueryCache","updateQuery","mounted","shouldFetchOptionally","updateResult","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","currentRefetchInterval","updateRefetchInterval","getOptimisticResult","createResult","currentResult","trackResult","trackedResult","configurable","getCurrentQuery","fetchOptimistic","defaultedOptions","_fetchOptions$cancelR","throwOnError","staleTimeoutId","_this$options$refetch","refetchInterval","nextInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","clearInterval","prevResult","prevResultState","currentResultState","prevResultOptions","currentResultOptions","queryChange","queryInitialState","currentQueryInitialState","prevQueryResult","previousQueryResult","isPreviousData","isPlaceholderData","_optimisticResults","fetchOnMount","fetchOptionally","keepPreviousData","isSuccess","select","selectFn","selectResult","placeholderData","isFetching","isLoading","isError","isInitialLoading","isFetched","isFetchedAfterMount","isRefetching","isLoadingError","isRefetchError","nextResult","defaultNotifyOptions","notifyOnChangeProps","size","includedProps","useErrorBoundary","typedKey","has","shouldNotifyListeners","retryOnMount","shouldLoadOnMount","refetchOnMount","field","suspense","QueriesObserver","observersMap","setQueries","onUpdate","prevObservers","newObserverMatches","findMatchingObservers","match","defaultedQueryOptions","newObservers","map","newObserversMap","fromEntries","newResult","hasIndexChange","index","getQueries","matchingObservers","flatMap","matchedQueryHashes","unmatchedQueries","unmatchedObservers","prevObserver","getObserver","currentObserver","newOrReusedObservers","previouslyUsedObserver","concat","slice","replaceAt","InfiniteQueryObserver","fetchNextPage","fetchPreviousPage","_state$data","_state$data2","_state$fetchMeta","_state$fetchMeta$fetc","_state$fetchMeta2","_state$fetchMeta2$fet","MutationObserver","mutate","getMutationCache","currentMutation","_this$currentMutation","mutateOptions","isIdle","_this$mutateOptions$o","_this$mutateOptions","_this$mutateOptions$o2","_this$mutateOptions2","_this$mutateOptions$o3","_this$mutateOptions3","_this$mutateOptions$o4","_this$mutateOptions4","defaultShouldDehydrateMutation","defaultShouldDehydrateQuery","VUE_QUERY_CLIENT","getClientKey","updateState","update","cloneDeep","customizer","isRef","getPrototypeOf","entries","cloneDeepUnref","obj","unref","useQueryClient","id","_getCurrentInstance","getCurrentInstance","proxy","queryClient","inject","QC","arg1Unreffed","arg2Unreffed","MC","QueryClient","queryCache","queryDefaults","mutationDefaults","mount","unsubscribeFocus","unsubscribeOnline","unmount","_this$unsubscribeFocu","_this$unsubscribeOnli","isMutating","getQueryData","_this$queryCache$find","getQueriesData","queryKeyOrFilters","setQueryData","updater","input","functionalUpdate","parsedOptions","setQueriesData","getQueryState","_this$queryCache$find2","removeQueries","resetQueries","refetchFilters","refetchQueries","cancelQueries","promises","all","invalidateQueries","_ref","_filters$refetchType","refetchType","_options$cancelRefetc","fetchQuery","prefetchQuery","fetchInfiniteQuery","prefetchInfiniteQuery","getDefaultOptions","setDefaultOptions","setQueryDefaults","firstMatchingDefaults","setMutationDefaults","_defaulted","unreffedConfig","unreffed","arg3Unreffed","VueQueryPlugin","install","app","clientKey","queryClientKey","contextSharing","__VUE_QUERY_CONTEXT__","clientConfig","queryClientConfig","onUnmount","originalUnmount","isVue2","mixin","beforeCreate","_provided","provideCache","set","v","assign","provide","useBaseQuery","Observer","_options$queryClient","getQueryUnreffedOptions","reactive","unsubscribe","watch","deep","onScopeDispose","toRefs","readonly","newOptions","optimisticResult","mergedOptions","parseMutationFilterArgs","dehydrateMutations","shouldDehydrateMutation","dehydrateMutation","dehydrateQueries","shouldDehydrateQuery","dehydrateQuery","dehydratedState","dehydratedMutation","_options$defaultOptio","dehydratedQuery","_options$defaultOptio2","_filters$value$queryC","ref","_options$value$queryC","computed","plainArg1","plainArg2","parseMutationArgs","mutateAsync","unreffedQueries","optionsQueryClient","defaultedQueries","splice","defaulted"],"mappings":"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"}