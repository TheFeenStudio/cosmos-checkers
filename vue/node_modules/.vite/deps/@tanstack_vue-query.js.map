{
  "version": 3,
  "sources": ["../../@tanstack/query-core/src/subscribable.ts", "../../@tanstack/query-core/src/utils.ts", "../../@tanstack/query-core/src/focusManager.ts", "../../@tanstack/query-core/src/onlineManager.ts", "../../@tanstack/query-core/src/retryer.ts", "../../@tanstack/query-core/src/logger.ts", "../../@tanstack/query-core/src/notifyManager.ts", "../../@tanstack/query-core/src/removable.ts", "../../@tanstack/query-core/src/query.ts", "../../@tanstack/query-core/src/queryCache.ts", "../../@tanstack/query-core/src/mutation.ts", "../../@tanstack/query-core/src/mutationCache.ts", "../../@tanstack/query-core/src/infiniteQueryBehavior.ts", "../../@tanstack/query-core/src/queryClient.ts", "../../@tanstack/query-core/src/queryObserver.ts", "../../@tanstack/query-core/src/queriesObserver.ts", "../../@tanstack/query-core/src/infiniteQueryObserver.ts", "../../@tanstack/query-core/src/mutationObserver.ts", "../../@tanstack/query-core/src/hydration.ts", "../../@tanstack/vue-query/node_modules/vue-demi/lib/index.mjs", "../../@tanstack/vue-query/src/utils.ts", "../../@tanstack/vue-query/src/useQueryClient.ts", "../../@tanstack/vue-query/src/queryCache.ts", "../../@tanstack/vue-query/src/mutationCache.ts", "../../@tanstack/vue-query/src/queryClient.ts", "../../@tanstack/match-sorter-utils/src/remove-accents.ts", "../../@tanstack/match-sorter-utils/src/index.ts", "../../@tanstack/vue-query/src/devtools/utils.ts", "../../@tanstack/vue-query/src/devtools/devtools.ts", "../../@tanstack/vue-query/src/vueQueryPlugin.ts", "../../@tanstack/vue-query/src/useBaseQuery.ts", "../../@tanstack/vue-query/src/useQuery.ts", "../../@tanstack/vue-query/src/useQueries.ts", "../../@tanstack/vue-query/src/useInfiniteQuery.ts", "../../@tanstack/vue-query/src/useMutation.ts", "../../@tanstack/vue-query/src/useIsFetching.ts", "../../@tanstack/vue-query/src/useIsMutating.ts"],
  "sourcesContent": ["type Listener = () => void\n\nexport class Subscribable<TListener extends Function = Listener> {\n  protected listeners: TListener[]\n\n  constructor() {\n    this.listeners = []\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  subscribe(listener: TListener): () => void {\n    this.listeners.push(listener as TListener)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners = this.listeners.filter((x) => x !== listener)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.length > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n", "import type { Mutation } from './mutation'\nimport type { Query } from './query'\nimport type {\n  FetchStatus,\n  MutationFunction,\n  MutationKey,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryOptions,\n} from './types'\n\n// TYPES\n\nexport interface QueryFilters {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: QueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (mutation: Mutation<any, any, any>) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Include or exclude fetching mutations\n   */\n  fetching?: boolean\n}\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined'\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function difference<T>(array1: T[], array2: T[]): T[] {\n  return array1.filter((x) => array2.indexOf(x) === -1)\n}\n\nexport function replaceAt<T>(array: T[], index: number, value: T): T[] {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function parseQueryArgs<\n  TOptions extends QueryOptions<any, any, any, TQueryKey>,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | TOptions,\n  arg2?: QueryFunction<any, TQueryKey> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (!isQueryKey(arg1)) {\n    return arg1 as TOptions\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3, queryKey: arg1, queryFn: arg2 } as TOptions\n  }\n\n  return { ...arg2, queryKey: arg1 } as TOptions\n}\n\nexport function parseMutationArgs<\n  TOptions extends MutationOptions<any, any, any, any>,\n>(\n  arg1: MutationKey | MutationFunction<any, any> | TOptions,\n  arg2?: MutationFunction<any, any> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3, mutationKey: arg1, mutationFn: arg2 } as TOptions\n    }\n    return { ...arg2, mutationKey: arg1 } as TOptions\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2, mutationFn: arg1 } as TOptions\n  }\n\n  return { ...arg1 } as TOptions\n}\n\nexport function parseFilterArgs<\n  TFilters extends QueryFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1) ? [{ ...arg2, queryKey: arg1 }, arg3] : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function parseMutationFilterArgs<\n  TFilters extends MutationFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1)\n      ? [{ ...arg2, mutationKey: arg1 }, arg3]\n      : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (\n    typeof fetchStatus !== 'undefined' &&\n    fetchStatus !== query.state.fetchStatus\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, fetching, predicate, mutationKey } = filters\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (\n        hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)\n      ) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (\n    typeof fetching === 'boolean' &&\n    (mutation.state.status === 'loading') !== fetching\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: QueryOptions<any, any, any, TQueryKey>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashQueryKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashQueryKey(queryKey: QueryKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean {\n  return partialDeepEqual(a, b)\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\nexport function shallowEqualObjects<T>(a: T, b: T): boolean {\n  if ((a && !b) || (b && !a)) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isQueryKey(value: unknown): value is QueryKey {\n  return Array.isArray(value)\n}\n\nexport function isError(value: any): value is Error {\n  return value instanceof Error\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout)\n  })\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nexport function scheduleMicrotask(callback: () => void) {\n  sleep(0).then(callback)\n}\n\nexport function getAbortController(): AbortController | undefined {\n  if (typeof AbortController === 'function') {\n    return new AbortController()\n  }\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual?.(prevData, data)) {\n    return prevData as TData\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data)\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n", "import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setFocused: (focused?: boolean) => void,\n) => (() => void) | undefined\n\nexport class FocusManager extends Subscribable {\n  private focused?: boolean\n  private cleanup?: () => void\n\n  private setup: SetupFn\n\n  constructor() {\n    super()\n    this.setup = (onFocus) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus()\n        // Listen to visibillitychange and focus\n        window.addEventListener('visibilitychange', listener, false)\n        window.addEventListener('focus', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener)\n          window.removeEventListener('focus', listener)\n        }\n      }\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.cleanup?.()\n      this.cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.setup = setup\n    this.cleanup?.()\n    this.cleanup = setup((focused) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    this.focused = focused\n\n    if (focused) {\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    this.listeners.forEach((listener) => {\n      listener()\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.focused === 'boolean') {\n      return this.focused\n    }\n\n    // document global can be unavailable in react native\n    if (typeof document === 'undefined') {\n      return true\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(\n      document.visibilityState,\n    )\n  }\n}\n\nexport const focusManager = new FocusManager()\n", "import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setOnline: (online?: boolean) => void,\n) => (() => void) | undefined\n\nexport class OnlineManager extends Subscribable {\n  private online?: boolean\n  private cleanup?: () => void\n\n  private setup: SetupFn\n\n  constructor() {\n    super()\n    this.setup = (onOnline) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline()\n        // Listen to online\n        window.addEventListener('online', listener, false)\n        window.addEventListener('offline', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', listener)\n          window.removeEventListener('offline', listener)\n        }\n      }\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.cleanup?.()\n      this.cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.setup = setup\n    this.cleanup?.()\n    this.cleanup = setup((online?: boolean) => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online)\n      } else {\n        this.onOnline()\n      }\n    })\n  }\n\n  setOnline(online?: boolean): void {\n    this.online = online\n\n    if (online) {\n      this.onOnline()\n    }\n  }\n\n  onOnline(): void {\n    this.listeners.forEach((listener) => {\n      listener()\n    })\n  }\n\n  isOnline(): boolean {\n    if (typeof this.online === 'boolean') {\n      return this.online\n    }\n\n    if (\n      typeof navigator === 'undefined' ||\n      typeof navigator.onLine === 'undefined'\n    ) {\n      return true\n    }\n\n    return navigator.onLine\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n", "import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { sleep } from './utils'\nimport type { CancelOptions, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = unknown> {\n  fn: () => TData | Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => void\n  cancelRetry: () => void\n  continueRetry: () => void\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = unknown> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = unknown>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => void) | undefined\n  let promiseResolve: (data: TData) => void\n  let promiseReject: (error: TError) => void\n\n  const promise = new Promise<TData>((outerResolve, outerReject) => {\n    promiseResolve = outerResolve\n    promiseReject = outerReject\n  })\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const shouldPause = () =>\n    !focusManager.isFocused() ||\n    (config.networkMode !== 'always' && !onlineManager.isOnline())\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      promiseResolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      promiseReject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        if (isResolved || !shouldPause()) {\n          return continueResolve(value)\n        }\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // Execute query\n    try {\n      promiseOrValue = config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? 3\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            if (shouldPause()) {\n              return pause()\n            }\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  // Start loop\n  if (canFetch(config.networkMode)) {\n    run()\n  } else {\n    pause().then(run)\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      continueFn?.()\n    },\n    cancelRetry,\n    continueRetry,\n  }\n}\n", "export interface Logger {\n  log: LogFunction\n  warn: LogFunction\n  error: LogFunction\n}\n\ntype LogFunction = (...args: any[]) => void\n\nexport const defaultLogger: Logger = console\n", "import { scheduleMicrotask } from './utils'\n\n// TYPES\n\ntype NotifyCallback = () => void\n\ntype NotifyFunction = (callback: () => void) => void\n\ntype BatchNotifyFunction = (callback: () => void) => void\n\nexport function createNotifyManager() {\n  let queue: NotifyCallback[] = []\n  let transactions = 0\n  let notifyFn: NotifyFunction = (callback) => {\n    callback()\n  }\n  let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {\n    callback()\n  }\n\n  const batch = <T>(callback: () => T): T => {\n    let result\n    transactions++\n    try {\n      result = callback()\n    } finally {\n      transactions--\n      if (!transactions) {\n        flush()\n      }\n    }\n    return result\n  }\n\n  const schedule = (callback: NotifyCallback): void => {\n    if (transactions) {\n      queue.push(callback)\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback)\n      })\n    }\n  }\n\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n  const batchCalls = <T extends Function>(callback: T): T => {\n    return ((...args: any[]) => {\n      schedule(() => {\n        callback(...args)\n      })\n    }) as any\n  }\n\n  const flush = (): void => {\n    const originalQueue = queue\n    queue = []\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback)\n          })\n        })\n      })\n    }\n  }\n\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n  const setNotifyFunction = (fn: NotifyFunction) => {\n    notifyFn = fn\n  }\n\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n  const setBatchNotifyFunction = (fn: BatchNotifyFunction) => {\n    batchNotifyFn = fn\n  }\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction,\n  } as const\n}\n\n// SINGLETON\nexport const notifyManager = createNotifyManager()\n", "import { isServer, isValidTimeout } from './utils'\n\nexport abstract class Removable {\n  cacheTime!: number\n  private gcTimeout?: ReturnType<typeof setTimeout>\n\n  destroy(): void {\n    this.clearGcTimeout()\n  }\n\n  protected scheduleGc(): void {\n    this.clearGcTimeout()\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove()\n      }, this.cacheTime)\n    }\n  }\n\n  protected updateCacheTime(newCacheTime: number | undefined): void {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(\n      this.cacheTime || 0,\n      newCacheTime ?? (isServer ? Infinity : 5 * 60 * 1000),\n    )\n  }\n\n  protected clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout)\n      this.gcTimeout = undefined\n    }\n  }\n\n  protected abstract optionalRemove(): void\n}\n", "import { getAbortController, noop, replaceData, timeUntilStale } from './utils'\nimport type {\n  InitialDataFunction,\n  QueryKey,\n  QueryOptions,\n  QueryStatus,\n  QueryFunctionContext,\n  QueryMeta,\n  CancelOptions,\n  SetDataOptions,\n  FetchStatus,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport type { QueryObserver } from './queryObserver'\nimport type { Logger } from './logger'\nimport { defaultLogger } from './logger'\nimport { notifyManager } from './notifyManager'\nimport type { Retryer } from './retryer'\nimport { isCancelledError, canFetch, createRetryer } from './retryer'\nimport { Removable } from './removable'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  cache: QueryCache\n  queryKey: TQueryKey\n  queryHash: string\n  logger?: Logger\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n  meta: QueryMeta | undefined\n}\n\nexport interface QueryState<TData = unknown, TError = unknown> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: any\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal?: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n  meta: QueryMeta | undefined\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n  ) => void\n}\n\nexport interface FetchOptions {\n  cancelRefetch?: boolean\n  meta?: any\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: any\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: QueryState<TData, TError>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  initialState: QueryState<TData, TError>\n  revertState?: QueryState<TData, TError>\n  state: QueryState<TData, TError>\n  meta: QueryMeta | undefined\n  isFetchingOptimistic?: boolean\n\n  private cache: QueryCache\n  private logger: Logger\n  private promise?: Promise<TData>\n  private retryer?: Retryer<TData>\n  private observers: QueryObserver<any, any, any, any, any>[]\n  private defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  private abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.abortSignalConsumed = false\n    this.defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.cache = config.cache\n    this.logger = config.logger || defaultLogger\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.initialState = config.state || getDefaultState(this.options)\n    this.state = this.initialState\n    this.meta = config.meta\n  }\n\n  private setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.defaultOptions, ...options }\n\n    this.meta = options?.meta\n\n    this.updateCacheTime(this.options.cacheTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: QueryState<TData, TError>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.promise\n    this.retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some((observer) => observer.options.enabled !== false)\n  }\n\n  isDisabled(): boolean {\n    return this.getObserversCount() > 0 && !this.isActive()\n  }\n\n  isStale(): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      this.observers.some((observer) => observer.getCurrentResult().isStale)\n    )\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n    )\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    if (observer) {\n      observer.refetch({ cancelRefetch: false })\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    if (observer) {\n      observer.refetch({ cancelRefetch: false })\n    }\n\n    // Continue fetch if currently paused\n    this.retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({ revert: true })\n          } else {\n            this.retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({ silent: true })\n      } else if (this.promise) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.retryer?.continueRetry()\n        // Return current promise if we are already fetching\n        return this.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = getAbortController()\n\n    // Create query function context\n    const queryFnContext: QueryFunctionContext<TQueryKey> = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta,\n    }\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true\n            return abortController.signal\n          }\n          return undefined\n        },\n      })\n    }\n\n    addSignalProperty(queryFnContext)\n\n    // Create fetch function\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject('Missing queryFn')\n      }\n      this.abortSignalConsumed = false\n      return this.options.queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const context: FetchContext<TQueryFnData, TError, TData, TQueryKey> = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n      meta: this.meta,\n    }\n\n    addSignalProperty(context)\n\n    this.options.behavior?.onFetch(context)\n\n    // Store state in case the current fetch needs to be reverted\n    this.revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.cache.config.onError?.(error, this as Query<any, any, any, any>)\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error)\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      }\n      this.isFetchingOptimistic = false\n    }\n\n    // Try to fetch the data\n    this.retryer = createRetryer({\n      fn: context.fetchFn as () => TData,\n      abort: abortController?.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (typeof data === 'undefined') {\n          if (process.env.NODE_ENV !== 'production') {\n            this.logger.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error('undefined') as any)\n          return\n        }\n\n        this.setData(data as TData)\n\n        // Notify cache callback\n        this.cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc()\n        }\n        this.isFetchingOptimistic = false\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n    })\n\n    this.promise = this.retryer.promise\n\n    return this.promise\n  }\n\n  private dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: action.meta ?? null,\n            fetchStatus: canFetch(this.options.networkMode)\n              ? 'fetching'\n              : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading',\n            }),\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error as unknown\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState }\n          }\n\n          return {\n            ...state,\n            error: error as TError,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error as TError,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate(action)\n      })\n\n      this.cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasInitialData = typeof options.initialData !== 'undefined'\n\n  const initialDataUpdatedAt = hasInitialData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  const hasData = typeof data !== 'undefined'\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle',\n  }\n}\n", "import type { QueryFilters } from './utils'\nimport { hashQueryKeyByOptions, matchQuery, parseFilterArgs } from './utils'\nimport type { Action, QueryState } from './query'\nimport { Query } from './query'\nimport type { QueryKey, QueryOptions } from './types'\nimport { notifyManager } from './notifyManager'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\nimport type { QueryObserver } from './queryObserver'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  onError?: (error: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSuccess?: (data: unknown, query: Query<unknown, unknown, unknown>) => void\n}\n\ninterface QueryHashMap {\n  [hash: string]: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryAdded {\n  type: 'added'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryRemoved {\n  type: 'removed'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryUpdated {\n  type: 'updated'\n  query: Query<any, any, any, any>\n  action: Action<any, any>\n}\n\ninterface NotifyEventQueryObserverAdded {\n  type: 'observerAdded'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverRemoved {\n  type: 'observerRemoved'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverResultsUpdated {\n  type: 'observerResultsUpdated'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverOptionsUpdated {\n  type: 'observerOptionsUpdated'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ntype QueryCacheNotifyEvent =\n  | NotifyEventQueryAdded\n  | NotifyEventQueryRemoved\n  | NotifyEventQueryUpdated\n  | NotifyEventQueryObserverAdded\n  | NotifyEventQueryObserverRemoved\n  | NotifyEventQueryObserverResultsUpdated\n  | NotifyEventQueryObserverOptionsUpdated\n\ntype QueryCacheListener = (event: QueryCacheNotifyEvent) => void\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  config: QueryCacheConfig\n\n  private queries: Query<any, any, any, any>[]\n  private queriesMap: QueryHashMap\n\n  constructor(config?: QueryCacheConfig) {\n    super()\n    this.config = config || {}\n    this.queries = []\n    this.queriesMap = {}\n  }\n\n  build<TQueryFnData, TError, TData, TQueryKey extends QueryKey>(\n    client: QueryClient,\n    options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    state?: QueryState<TData, TError>,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> {\n    const queryKey = options.queryKey!\n    const queryHash =\n      options.queryHash ?? hashQueryKeyByOptions(queryKey, options)\n    let query = this.get<TQueryFnData, TError, TData, TQueryKey>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n        meta: options.meta,\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any, any, any>): void {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query\n      this.queries.push(query)\n      this.notify({\n        type: 'added',\n        query,\n      })\n    }\n  }\n\n  remove(query: Query<any, any, any, any>): void {\n    const queryInMap = this.queriesMap[query.queryHash]\n\n    if (queryInMap) {\n      query.destroy()\n\n      this.queries = this.queries.filter((x) => x !== query)\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash]\n      }\n\n      this.notify({ type: 'removed', query })\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach((query) => {\n        this.remove(query)\n      })\n    })\n  }\n\n  get<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueyKey extends QueryKey = QueryKey,\n  >(\n    queryHash: string,\n  ): Query<TQueryFnData, TError, TData, TQueyKey> | undefined {\n    return this.queriesMap[queryHash]\n  }\n\n  getAll(): Query[] {\n    return this.queries\n  }\n\n  find<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    arg1: QueryKey,\n    arg2?: QueryFilters,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const [filters] = parseFilterArgs(arg1, arg2)\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true\n    }\n\n    return this.queries.find((query) => matchQuery(filters, query))\n  }\n\n  findAll(queryKey?: QueryKey, filters?: QueryFilters): Query[]\n  findAll(filters?: QueryFilters): Query[]\n  findAll(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): Query[]\n  findAll(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): Query[] {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    return Object.keys(filters).length > 0\n      ? this.queries.filter((query) => matchQuery(filters, query))\n      : this.queries\n  }\n\n  notify(event: QueryCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  onFocus(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach((query) => {\n        query.onFocus()\n      })\n    })\n  }\n\n  onOnline(): void {\n    notifyManager.batch(() => {\n      this.queries.forEach((query) => {\n        query.onOnline()\n      })\n    })\n  }\n}\n", "import type { MutationOptions, MutationStatus, MutationMeta } from './types'\nimport type { MutationCache } from './mutationCache'\nimport type { MutationObserver } from './mutationObserver'\nimport type { Logger } from './logger'\nimport { defaultLogger } from './logger'\nimport { notifyManager } from './notifyManager'\nimport { Removable } from './removable'\nimport type { Retryer } from './retryer'\nimport { canFetch, createRetryer } from './retryer'\n\n// TYPES\n\ninterface MutationConfig<TData, TError, TVariables, TContext> {\n  mutationId: number\n  mutationCache: MutationCache\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  logger?: Logger\n  defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  state?: MutationState<TData, TError, TVariables, TContext>\n  meta?: MutationMeta\n}\n\nexport interface MutationState<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> {\n  context: TContext | undefined\n  data: TData | undefined\n  error: TError | null\n  failureCount: number\n  failureReason: TError | null\n  isPaused: boolean\n  status: MutationStatus\n  variables: TVariables | undefined\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError | null\n}\n\ninterface LoadingAction<TVariables, TContext> {\n  type: 'loading'\n  variables?: TVariables\n  context?: TContext\n}\n\ninterface SuccessAction<TData> {\n  type: 'success'\n  data: TData\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError, TVariables, TContext> {\n  type: 'setState'\n  state: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport type Action<TData, TError, TVariables, TContext> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | LoadingAction<TVariables, TContext>\n  | PauseAction\n  | SetStateAction<TData, TError, TVariables, TContext>\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Mutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> extends Removable {\n  state: MutationState<TData, TError, TVariables, TContext>\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  mutationId: number\n  meta: MutationMeta | undefined\n\n  private observers: MutationObserver<TData, TError, TVariables, TContext>[]\n  private mutationCache: MutationCache\n  private logger: Logger\n  private retryer?: Retryer<TData>\n\n  constructor(config: MutationConfig<TData, TError, TVariables, TContext>) {\n    super()\n\n    this.options = {\n      ...config.defaultOptions,\n      ...config.options,\n    }\n    this.mutationId = config.mutationId\n    this.mutationCache = config.mutationCache\n    this.logger = config.logger || defaultLogger\n    this.observers = []\n    this.state = config.state || getDefaultState()\n    this.meta = config.meta\n\n    this.updateCacheTime(this.options.cacheTime)\n    this.scheduleGc()\n  }\n\n  setState(state: MutationState<TData, TError, TVariables, TContext>): void {\n    this.dispatch({ type: 'setState', state })\n  }\n\n  addObserver(observer: MutationObserver<any, any, any, any>): void {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer)\n\n      // Stop the mutation from being garbage collected\n      this.clearGcTimeout()\n\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer,\n      })\n    }\n  }\n\n  removeObserver(observer: MutationObserver<any, any, any, any>): void {\n    this.observers = this.observers.filter((x) => x !== observer)\n\n    this.scheduleGc()\n\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer,\n    })\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc()\n      } else {\n        this.mutationCache.remove(this)\n      }\n    }\n  }\n\n  continue(): Promise<TData> {\n    if (this.retryer) {\n      this.retryer.continue()\n      return this.retryer.promise\n    }\n    return this.execute()\n  }\n\n  async execute(): Promise<TData> {\n    const executeMutation = () => {\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found')\n          }\n          return this.options.mutationFn(this.state.variables!)\n        },\n        onFail: (failureCount, error) => {\n          this.dispatch({ type: 'failed', failureCount, error })\n        },\n        onPause: () => {\n          this.dispatch({ type: 'pause' })\n        },\n        onContinue: () => {\n          this.dispatch({ type: 'continue' })\n        },\n        retry: this.options.retry ?? 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode,\n      })\n\n      return this.retryer.promise\n    }\n\n    const restored = this.state.status === 'loading'\n    try {\n      if (!restored) {\n        this.dispatch({ type: 'loading', variables: this.options.variables! })\n        // Notify cache callback\n        await this.mutationCache.config.onMutate?.(\n          this.state.variables,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n        const context = await this.options.onMutate?.(this.state.variables!)\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables,\n          })\n        }\n      }\n      const data = await executeMutation()\n\n      // Notify cache callback\n      await this.mutationCache.config.onSuccess?.(\n        data,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSuccess?.(\n        data,\n        this.state.variables!,\n        this.state.context!,\n      )\n\n      await this.options.onSettled?.(\n        data,\n        null,\n        this.state.variables!,\n        this.state.context,\n      )\n\n      this.dispatch({ type: 'success', data })\n      return data\n    } catch (error) {\n      try {\n        // Notify cache callback\n        await this.mutationCache.config.onError?.(\n          error,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error)\n        }\n\n        await this.options.onError?.(\n          error as TError,\n          this.state.variables!,\n          this.state.context,\n        )\n\n        await this.options.onSettled?.(\n          undefined,\n          error as TError,\n          this.state.variables!,\n          this.state.context,\n        )\n        throw error\n      } finally {\n        this.dispatch({ type: 'error', error: error as TError })\n      }\n    }\n  }\n\n  private dispatch(action: Action<TData, TError, TVariables, TContext>): void {\n    const reducer = (\n      state: MutationState<TData, TError, TVariables, TContext>,\n    ): MutationState<TData, TError, TVariables, TContext> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            isPaused: true,\n          }\n        case 'continue':\n          return {\n            ...state,\n            isPaused: false,\n          }\n        case 'loading':\n          return {\n            ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables,\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false,\n          }\n        case 'error':\n          return {\n            ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error',\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onMutationUpdate(action)\n      })\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action,\n      })\n    })\n  }\n}\n\nexport function getDefaultState<\n  TData,\n  TError,\n  TVariables,\n  TContext,\n>(): MutationState<TData, TError, TVariables, TContext> {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined,\n  }\n}\n", "import type { MutationObserver } from './mutationObserver'\nimport type { MutationOptions } from './types'\nimport type { QueryClient } from './queryClient'\nimport { notifyManager } from './notifyManager'\nimport type { Action, MutationState } from './mutation'\nimport { Mutation } from './mutation'\nimport type { MutationFilters } from './utils'\nimport { matchMutation, noop } from './utils'\nimport { Subscribable } from './subscribable'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n}\n\ninterface NotifyEventMutationAdded {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverOptionsUpdated {\n  type: 'observerOptionsUpdated'\n  mutation?: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any, any>\n}\n\ninterface NotifyEventMutationUpdated {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\ntype MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationObserverOptionsUpdated\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  config: MutationCacheConfig\n\n  private mutations: Mutation<any, any, any, any>[]\n  private mutationId: number\n\n  constructor(config?: MutationCacheConfig) {\n    super()\n    this.config = config || {}\n    this.mutations = []\n    this.mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>,\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey\n        ? client.getMutationDefaults(options.mutationKey)\n        : undefined,\n      meta: options.meta,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.mutations.push(mutation)\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    this.mutations = this.mutations.filter((x) => x !== mutation)\n    this.notify({ type: 'removed', mutation })\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.mutations.forEach((mutation) => {\n        this.remove(mutation)\n      })\n    })\n  }\n\n  getAll(): Mutation[] {\n    return this.mutations\n  }\n\n  find<TData = unknown, TError = unknown, TVariables = any, TContext = unknown>(\n    filters: MutationFilters,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true\n    }\n\n    return this.mutations.find((mutation) => matchMutation(filters, mutation))\n  }\n\n  findAll(filters: MutationFilters): Mutation[] {\n    return this.mutations.filter((mutation) => matchMutation(filters, mutation))\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<void> {\n    const pausedMutations = this.mutations.filter((x) => x.state.isPaused)\n    return notifyManager.batch(() =>\n      pausedMutations.reduce(\n        (promise, mutation) =>\n          promise.then(() => mutation.continue().catch(noop)),\n        Promise.resolve(),\n      ),\n    )\n  }\n}\n", "import type { QueryBehavior } from './query'\n\nimport type {\n  InfiniteData,\n  QueryFunctionContext,\n  QueryOptions,\n  RefetchQueryFilters,\n} from './types'\n\nexport function infiniteQueryBehavior<\n  TQueryFnData,\n  TError,\n  TData,\n>(): QueryBehavior<TQueryFnData, TError, InfiniteData<TData>> {\n  return {\n    onFetch: (context) => {\n      context.fetchFn = () => {\n        const refetchPage: RefetchQueryFilters['refetchPage'] | undefined =\n          context.fetchOptions?.meta?.refetchPage\n        const fetchMore = context.fetchOptions?.meta?.fetchMore\n        const pageParam = fetchMore?.pageParam\n        const isFetchingNextPage = fetchMore?.direction === 'forward'\n        const isFetchingPreviousPage = fetchMore?.direction === 'backward'\n        const oldPages = context.state.data?.pages || []\n        const oldPageParams = context.state.data?.pageParams || []\n        let newPageParams = oldPageParams\n        let cancelled = false\n\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal?.aborted) {\n                cancelled = true\n              } else {\n                context.signal?.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        // Get query function\n        const queryFn =\n          context.options.queryFn || (() => Promise.reject('Missing queryFn'))\n\n        const buildNewPages = (\n          pages: unknown[],\n          param: unknown,\n          page: unknown,\n          previous?: boolean,\n        ) => {\n          newPageParams = previous\n            ? [param, ...newPageParams]\n            : [...newPageParams, param]\n          return previous ? [page, ...pages] : [...pages, page]\n        }\n\n        // Create function to fetch a page\n        const fetchPage = (\n          pages: unknown[],\n          manual?: boolean,\n          param?: unknown,\n          previous?: boolean,\n        ): Promise<unknown[]> => {\n          if (cancelled) {\n            return Promise.reject('Cancelled')\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages)\n          }\n\n          const queryFnContext: QueryFunctionContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.meta,\n          }\n\n          addSignalProperty(queryFnContext)\n\n          const queryFnResult = queryFn(queryFnContext)\n\n          const promise = Promise.resolve(queryFnResult).then((page) =>\n            buildNewPages(pages, param, page, previous),\n          )\n\n          return promise\n        }\n\n        let promise: Promise<unknown[]>\n\n        // Fetch first page?\n        if (!oldPages.length) {\n          promise = fetchPage([])\n        }\n\n        // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getNextPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param)\n        }\n\n        // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getPreviousPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param, true)\n        }\n\n        // Refetch pages\n        else {\n          newPageParams = []\n\n          const manual = typeof context.options.getNextPageParam === 'undefined'\n\n          const shouldFetchFirstPage =\n            refetchPage && oldPages[0]\n              ? refetchPage(oldPages[0], 0, oldPages)\n              : true\n\n          // Fetch first page\n          promise = shouldFetchFirstPage\n            ? fetchPage([], manual, oldPageParams[0])\n            : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]))\n\n          // Fetch remaining pages\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then((pages) => {\n              const shouldFetchNextPage =\n                refetchPage && oldPages[i]\n                  ? refetchPage(oldPages[i], i, oldPages)\n                  : true\n\n              if (shouldFetchNextPage) {\n                const param = manual\n                  ? oldPageParams[i]\n                  : getNextPageParam(context.options, pages)\n                return fetchPage(pages, manual, param)\n              }\n              return Promise.resolve(\n                buildNewPages(pages, oldPageParams[i], oldPages[i]),\n              )\n            })\n          }\n        }\n\n        const finalPromise = promise.then((pages) => ({\n          pages,\n          pageParams: newPageParams,\n        }))\n\n        return finalPromise\n      }\n    },\n  }\n}\n\nexport function getNextPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[],\n): unknown | undefined {\n  return options.getNextPageParam?.(pages[pages.length - 1], pages)\n}\n\nexport function getPreviousPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[],\n): unknown | undefined {\n  return options.getPreviousPageParam?.(pages[0], pages)\n}\n\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasNextPage(\n  options: QueryOptions<any, any, any, any>,\n  pages?: unknown,\n): boolean | undefined {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages)\n    return (\n      typeof nextPageParam !== 'undefined' &&\n      nextPageParam !== null &&\n      nextPageParam !== false\n    )\n  }\n}\n\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasPreviousPage(\n  options: QueryOptions<any, any, any, any>,\n  pages?: unknown,\n): boolean | undefined {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages)\n    return (\n      typeof previousPageParam !== 'undefined' &&\n      previousPageParam !== null &&\n      previousPageParam !== false\n    )\n  }\n}\n", "import type { QueryFilters, Updater, MutationFilters } from './utils'\nimport {\n  hashQueryKey,\n  noop,\n  parseFilterArgs,\n  parseQueryArgs,\n  partialMatchKey,\n  hashQueryKeyByOptions,\n  functionalUpdate,\n} from './utils'\nimport type {\n  QueryClientConfig,\n  DefaultOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  ResetQueryFilters,\n  SetDataOptions,\n} from './types'\nimport type { QueryState } from './query'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\nimport type { CancelOptions, DefaultedQueryObserverOptions } from './types'\nimport type { Logger } from './logger'\nimport { defaultLogger } from './logger'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: QueryOptions<any, any, any>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  private queryCache: QueryCache\n  private mutationCache: MutationCache\n  private logger: Logger\n  private defaultOptions: DefaultOptions\n  private queryDefaults: QueryDefaults[]\n  private mutationDefaults: MutationDefaults[]\n  private unsubscribeFocus?: () => void\n  private unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.queryCache = config.queryCache || new QueryCache()\n    this.mutationCache = config.mutationCache || new MutationCache()\n    this.logger = config.logger || defaultLogger\n    this.defaultOptions = config.defaultOptions || {}\n    this.queryDefaults = []\n    this.mutationDefaults = []\n  }\n\n  mount(): void {\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations()\n        this.queryCache.onFocus()\n      }\n    })\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations()\n        this.queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.unsubscribeFocus?.()\n    this.unsubscribeOnline?.()\n  }\n\n  isFetching(filters?: QueryFilters): number\n  isFetching(queryKey?: QueryKey, filters?: QueryFilters): number\n  isFetching(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): number {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    filters.fetchStatus = 'fetching'\n    return this.queryCache.findAll(filters).length\n  }\n\n  isMutating(filters?: MutationFilters): number {\n    return this.mutationCache.findAll({ ...filters, fetching: true }).length\n  }\n\n  getQueryData<TQueryFnData = unknown>(\n    queryKey: QueryKey,\n    filters?: QueryFilters,\n  ): TQueryFnData | undefined {\n    return this.queryCache.find<TQueryFnData>(queryKey, filters)?.state.data\n  }\n\n  getQueriesData<TQueryFnData = unknown>(\n    queryKey: QueryKey,\n  ): [QueryKey, TQueryFnData | undefined][]\n  getQueriesData<TQueryFnData = unknown>(\n    filters: QueryFilters,\n  ): [QueryKey, TQueryFnData | undefined][]\n  getQueriesData<TQueryFnData = unknown>(\n    queryKeyOrFilters: QueryKey | QueryFilters,\n  ): [QueryKey, TQueryFnData | undefined][] {\n    return this.getQueryCache()\n      .findAll(queryKeyOrFilters)\n      .map(({ queryKey, state }) => {\n        const data = state.data as TQueryFnData | undefined\n        return [queryKey, data]\n      })\n  }\n\n  setQueryData<TQueryFnData>(\n    queryKey: QueryKey,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): TQueryFnData | undefined {\n    const query = this.queryCache.find<TQueryFnData>(queryKey)\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (typeof data === 'undefined') {\n      return undefined\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n    return this.queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<TQueryFnData>(\n    queryKey: QueryKey,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][]\n\n  setQueriesData<TQueryFnData>(\n    filters: QueryFilters,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][]\n\n  setQueriesData<TQueryFnData>(\n    queryKeyOrFilters: QueryKey | QueryFilters,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][] {\n    return notifyManager.batch(() =>\n      this.getQueryCache()\n        .findAll(queryKeyOrFilters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TQueryFnData>(queryKey, updater, options),\n        ]),\n    )\n  }\n\n  getQueryState<TQueryFnData = unknown, TError = undefined>(\n    queryKey: QueryKey,\n    filters?: QueryFilters,\n  ): QueryState<TQueryFnData, TError> | undefined {\n    return this.queryCache.find<TQueryFnData, TError>(queryKey, filters)?.state\n  }\n\n  removeQueries(filters?: QueryFilters): void\n  removeQueries(queryKey?: QueryKey, filters?: QueryFilters): void\n  removeQueries(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): void {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    const queryCache = this.queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries<TPageData = unknown>(\n    filters?: ResetQueryFilters<TPageData>,\n    options?: ResetOptions,\n  ): Promise<void>\n  resetQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: ResetQueryFilters<TPageData>,\n    options?: ResetOptions,\n  ): Promise<void>\n  resetQueries(\n    arg1?: QueryKey | ResetQueryFilters,\n    arg2?: ResetQueryFilters | ResetOptions,\n    arg3?: ResetOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n    const queryCache = this.queryCache\n\n    const refetchFilters: RefetchQueryFilters = {\n      type: 'active',\n      ...filters,\n    }\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset()\n      })\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  cancelQueries(filters?: QueryFilters, options?: CancelOptions): Promise<void>\n  cancelQueries(\n    queryKey?: QueryKey,\n    filters?: QueryFilters,\n    options?: CancelOptions,\n  ): Promise<void>\n  cancelQueries(\n    arg1?: QueryKey | QueryFilters,\n    arg2?: QueryFilters | CancelOptions,\n    arg3?: CancelOptions,\n  ): Promise<void> {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3)\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true\n    }\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache\n        .findAll(filters)\n        .map((query) => query.cancel(cancelOptions)),\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries<TPageData = unknown>(\n    filters?: InvalidateQueryFilters<TPageData>,\n    options?: InvalidateOptions,\n  ): Promise<void>\n  invalidateQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: InvalidateQueryFilters<TPageData>,\n    options?: InvalidateOptions,\n  ): Promise<void>\n  invalidateQueries(\n    arg1?: QueryKey | InvalidateQueryFilters,\n    arg2?: InvalidateQueryFilters | InvalidateOptions,\n    arg3?: InvalidateOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    return notifyManager.batch(() => {\n      this.queryCache.findAll(filters).forEach((query) => {\n        query.invalidate()\n      })\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      const refetchFilters: RefetchQueryFilters = {\n        ...filters,\n        type: filters.refetchType ?? filters.type ?? 'active',\n      }\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  refetchQueries<TPageData = unknown>(\n    filters?: RefetchQueryFilters<TPageData>,\n    options?: RefetchOptions,\n  ): Promise<void>\n  refetchQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: RefetchQueryFilters<TPageData>,\n    options?: RefetchOptions,\n  ): Promise<void>\n  refetchQueries(\n    arg1?: QueryKey | RefetchQueryFilters,\n    arg2?: RefetchQueryFilters | RefetchOptions,\n    arg3?: RefetchOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache\n        .findAll(filters)\n        .filter((query) => !query.isDisabled())\n        .map((query) =>\n          query.fetch(undefined, {\n            ...options,\n            cancelRefetch: options?.cancelRefetch ?? true,\n            meta: { refetchPage: filters.refetchPage },\n          }),\n        ),\n    )\n\n    let promise = Promise.all(promises).then(noop)\n\n    if (!options?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(defaultedOptions.staleTime)\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    parsedOptions.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData\n    >()\n    return this.fetchQuery(parsedOptions)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  resumePausedMutations(): Promise<void> {\n    return this.mutationCache.resumePausedMutations()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.mutationCache\n  }\n\n  getLogger(): Logger {\n    return this.logger\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.defaultOptions = options\n  }\n\n  setQueryDefaults(\n    queryKey: QueryKey,\n    options: QueryObserverOptions<unknown, any, any, any>,\n  ): void {\n    const result = this.queryDefaults.find(\n      (x) => hashQueryKey(queryKey) === hashQueryKey(x.queryKey),\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.queryDefaults.push({ queryKey, defaultOptions: options })\n    }\n  }\n\n  getQueryDefaults(\n    queryKey?: QueryKey,\n  ): QueryObserverOptions<any, any, any, any, any> | undefined {\n    if (!queryKey) {\n      return undefined\n    }\n\n    // Get the first matching defaults\n    const firstMatchingDefaults = this.queryDefaults.find((x) =>\n      partialMatchKey(queryKey, x.queryKey),\n    )\n\n    // Additional checks and error in dev mode\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter((x) =>\n        partialMatchKey(queryKey, x.queryKey),\n      )\n      // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\n          `[QueryClient] Several query defaults match with key '${JSON.stringify(\n            queryKey,\n          )}'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.`,\n        )\n      }\n    }\n\n    return firstMatchingDefaults?.defaultOptions\n  }\n\n  setMutationDefaults(\n    mutationKey: MutationKey,\n    options: MutationObserverOptions<any, any, any, any>,\n  ): void {\n    const result = this.mutationDefaults.find(\n      (x) => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey),\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.mutationDefaults.push({ mutationKey, defaultOptions: options })\n    }\n  }\n\n  getMutationDefaults(\n    mutationKey?: MutationKey,\n  ): MutationObserverOptions<any, any, any, any> | undefined {\n    if (!mutationKey) {\n      return undefined\n    }\n\n    // Get the first matching defaults\n    const firstMatchingDefaults = this.mutationDefaults.find((x) =>\n      partialMatchKey(mutationKey, x.mutationKey),\n    )\n\n    // Additional checks and error in dev mode\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter((x) =>\n        partialMatchKey(mutationKey, x.mutationKey),\n      )\n      // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\n          `[QueryClient] Several mutation defaults match with key '${JSON.stringify(\n            mutationKey,\n          )}'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.`,\n        )\n      }\n    }\n\n    return firstMatchingDefaults?.defaultOptions\n  }\n\n  defaultQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey extends QueryKey,\n  >(\n    options?:\n      | QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options?._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options?.queryKey),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions,\n      )\n    }\n\n    // dependent default values\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T,\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options?.mutationKey),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.queryCache.clear()\n    this.mutationCache.clear()\n  }\n}\n", "import type { DefaultedQueryObserverOptions, RefetchPageFilters } from './types'\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport type {\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\nimport type { Query, QueryState, Action, FetchOptions } from './query'\nimport type { QueryClient } from './queryClient'\nimport { focusManager } from './focusManager'\nimport { Subscribable } from './subscribable'\nimport { canFetch, isCancelledError } from './retryer'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\nexport interface NotifyOptions {\n  cache?: boolean\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\nexport interface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  options: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n\n  private client: QueryClient\n  private currentQuery!: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  private currentQueryInitialState!: QueryState<TQueryData, TError>\n  private currentResult!: QueryObserverResult<TData, TError>\n  private currentResultState?: QueryState<TQueryData, TError>\n  private currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  private previousQueryResult?: QueryObserverResult<TData, TError>\n  private selectError: TError | null\n  private selectFn?: (data: TQueryData) => TData\n  private selectResult?: TData\n  private staleTimeoutId?: ReturnType<typeof setTimeout>\n  private refetchIntervalId?: ReturnType<typeof setInterval>\n  private currentRefetchInterval?: number | false\n  private trackedProps!: Set<keyof QueryObserverResult>\n\n  constructor(\n    client: QueryClient,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.client = client\n    this.options = options\n    this.trackedProps = new Set()\n    this.selectError = null\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.remove = this.remove.bind(this)\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.length === 1) {\n      this.currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch()\n      }\n\n      this.updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = []\n    this.clearStaleTimeout()\n    this.clearRefetchInterval()\n    this.currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options?: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.currentQuery\n\n    this.options = this.client.defaultQueryOptions(options)\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.currentQuery,\n        observer: this,\n      })\n    }\n\n    if (\n      typeof this.options.enabled !== 'undefined' &&\n      typeof this.options.enabled !== 'boolean'\n    ) {\n      throw new Error('Expected enabled to be a boolean')\n    }\n\n    // Keep previous query key if the user does not supply one\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey\n    }\n\n    this.updateQuery()\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.executeFetch()\n    }\n\n    // Update result\n    this.updateResult(notifyOptions)\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        this.options.staleTime !== prevOptions.staleTime)\n    ) {\n      this.updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        nextRefetchInterval !== this.currentRefetchInterval)\n    ) {\n      this.updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.client.getQueryCache().build(this.client, options)\n\n    return this.createResult(query, options)\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n  ): QueryObserverResult<TData, TError> {\n    const trackedResult = {} as QueryObserverResult<TData, TError>\n\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key as keyof QueryObserverResult)\n          return result[key as keyof QueryObserverResult]\n        },\n      })\n    })\n\n    return trackedResult\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.currentQuery\n  }\n\n  remove(): void {\n    this.client.getQueryCache().remove(this.currentQuery)\n  }\n\n  refetch<TPageData>({\n    refetchPage,\n    ...options\n  }: RefetchOptions & RefetchPageFilters<TPageData> = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n      meta: { refetchPage },\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.client.defaultQueryOptions(options)\n\n    const query = this.client\n      .getQueryCache()\n      .build(this.client, defaultedOptions)\n    query.isFetchingOptimistic = true\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.currentResult\n    })\n  }\n\n  private executeFetch(\n    fetchOptions?: ObserverFetchOptions,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  private updateStaleTimeout(): void {\n    this.clearStaleTimeout()\n\n    if (\n      isServer ||\n      this.currentResult.isStale ||\n      !isValidTimeout(this.options.staleTime)\n    ) {\n      return\n    }\n\n    const time = timeUntilStale(\n      this.currentResult.dataUpdatedAt,\n      this.options.staleTime,\n    )\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  private computeRefetchInterval() {\n    return typeof this.options.refetchInterval === 'function'\n      ? this.options.refetchInterval(this.currentResult.data, this.currentQuery)\n      : this.options.refetchInterval ?? false\n  }\n\n  private updateRefetchInterval(nextInterval: number | false): void {\n    this.clearRefetchInterval()\n\n    this.currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      this.options.enabled === false ||\n      !isValidTimeout(this.currentRefetchInterval) ||\n      this.currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.executeFetch()\n      }\n    }, this.currentRefetchInterval)\n  }\n\n  private updateTimers(): void {\n    this.updateStaleTimeout()\n    this.updateRefetchInterval(this.computeRefetchInterval())\n  }\n\n  private clearStaleTimeout(): void {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId)\n      this.staleTimeoutId = undefined\n    }\n  }\n\n  private clearRefetchInterval(): void {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId)\n      this.refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.currentQuery\n    const prevOptions = this.options\n    const prevResult = this.currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.currentResultState\n    const prevResultOptions = this.currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.currentQueryInitialState\n    const prevQueryResult = queryChange\n      ? this.currentResult\n      : this.previousQueryResult\n\n    const { state } = query\n    let { dataUpdatedAt, error, errorUpdatedAt, fetchStatus, status } = state\n    let isPreviousData = false\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode)\n          ? 'fetching'\n          : 'paused'\n        if (!dataUpdatedAt) {\n          status = 'loading'\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle'\n      }\n    }\n\n    // Keep previous data if needed\n    if (\n      options.keepPreviousData &&\n      !state.dataUpdateCount &&\n      prevQueryResult?.isSuccess &&\n      status !== 'error'\n    ) {\n      data = prevQueryResult.data\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt\n      status = prevQueryResult.status\n      isPreviousData = true\n    }\n    // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (\n        prevResult &&\n        state.data === prevResultState?.data &&\n        options.select === this.selectFn\n      ) {\n        data = this.selectResult\n      } else {\n        try {\n          this.selectFn = options.select\n          data = options.select(state.data)\n          data = replaceData(prevResult?.data, data, options)\n          this.selectResult = data\n          this.selectError = null\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError)\n          }\n          this.selectError = selectError as TError\n        }\n      }\n    }\n    // Use query data\n    else {\n      data = state.data as unknown as TData\n    }\n\n    // Show placeholder data if needed\n    if (\n      typeof options.placeholderData !== 'undefined' &&\n      typeof data === 'undefined' &&\n      status === 'loading'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n      } else {\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (options.placeholderData as PlaceholderDataFunction<TQueryData>)()\n            : options.placeholderData\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData)\n            this.selectError = null\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError)\n            }\n            this.selectError = selectError as TError\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success'\n        data = replaceData(prevResult?.data, placeholderData, options) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError as any\n      data = this.selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = fetchStatus === 'fetching'\n    const isLoading = status === 'loading'\n    const isError = status === 'error'\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus,\n      isLoading,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading && isFetching,\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        state.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isLoading,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove,\n    }\n\n    return result as QueryObserverResult<TData, TError>\n  }\n\n  updateResult(notifyOptions?: NotifyOptions): void {\n    const prevResult = this.currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.currentQuery, this.options)\n    this.currentResultState = this.currentQuery.state\n    this.currentResultOptions = this.options\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.currentResult = nextResult\n\n    // Determine which callbacks to trigger\n    const defaultNotifyOptions: NotifyOptions = { cache: true }\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n\n      if (\n        notifyOnChangeProps === 'all' ||\n        (!notifyOnChangeProps && !this.trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(notifyOnChangeProps ?? this.trackedProps)\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey]\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true\n    }\n\n    this.notify({ ...defaultNotifyOptions, ...notifyOptions })\n  }\n\n  private updateQuery(): void {\n    const query = this.client.getQueryCache().build(this.client, this.options)\n\n    if (query === this.currentQuery) {\n      return\n    }\n\n    const prevQuery = this.currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.currentQuery = query\n    this.currentQueryInitialState = query.state\n    this.previousQueryResult = this.currentResult\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(action: Action<TData, TError>): void {\n    const notifyOptions: NotifyOptions = {}\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true\n    }\n\n    this.updateResult(notifyOptions)\n\n    if (this.hasListeners()) {\n      this.updateTimers()\n    }\n  }\n\n  private notify(notifyOptions: NotifyOptions): void {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        this.options.onSuccess?.(this.currentResult.data!)\n        this.options.onSettled?.(this.currentResult.data!, null)\n      } else if (notifyOptions.onError) {\n        this.options.onError?.(this.currentResult.error!)\n        this.options.onSettled?.(undefined, this.currentResult.error!)\n      }\n\n      // Then trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated',\n        })\n      }\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    !query.state.dataUpdatedAt &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.dataUpdatedAt > 0 &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: typeof options['refetchOnMount'] &\n    typeof options['refetchOnWindowFocus'] &\n    typeof options['refetchOnReconnect'],\n) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    (query !== prevQuery || prevOptions.enabled === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return query.isStaleByTime(options.staleTime)\n}\n", "import { difference, replaceAt } from './utils'\nimport { notifyManager } from './notifyManager'\nimport type {\n  QueryObserverOptions,\n  QueryObserverResult,\n  DefaultedQueryObserverOptions,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { NotifyOptions } from './queryObserver'\nimport { QueryObserver } from './queryObserver'\nimport { Subscribable } from './subscribable'\n\ntype QueriesObserverListener = (result: QueryObserverResult[]) => void\n\nexport class QueriesObserver extends Subscribable<QueriesObserverListener> {\n  private client: QueryClient\n  private result: QueryObserverResult[]\n  private queries: QueryObserverOptions[]\n  private observers: QueryObserver[]\n  private observersMap: Record<string, QueryObserver>\n\n  constructor(client: QueryClient, queries?: QueryObserverOptions[]) {\n    super()\n\n    this.client = client\n    this.queries = []\n    this.result = []\n    this.observers = []\n    this.observersMap = {}\n\n    if (queries) {\n      this.setQueries(queries)\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.length === 1) {\n      this.observers.forEach((observer) => {\n        observer.subscribe((result) => {\n          this.onUpdate(observer, result)\n        })\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.destroy()\n    }\n  }\n\n  destroy(): void {\n    this.listeners = []\n    this.observers.forEach((observer) => {\n      observer.destroy()\n    })\n  }\n\n  setQueries(\n    queries: QueryObserverOptions[],\n    notifyOptions?: NotifyOptions,\n  ): void {\n    this.queries = queries\n\n    notifyManager.batch(() => {\n      const prevObservers = this.observers\n\n      const newObserverMatches = this.findMatchingObservers(this.queries)\n\n      // set options for the new observers to notify of changes\n      newObserverMatches.forEach((match) =>\n        match.observer.setOptions(match.defaultedQueryOptions, notifyOptions),\n      )\n\n      const newObservers = newObserverMatches.map((match) => match.observer)\n      const newObserversMap = Object.fromEntries(\n        newObservers.map((observer) => [observer.options.queryHash, observer]),\n      )\n      const newResult = newObservers.map((observer) =>\n        observer.getCurrentResult(),\n      )\n\n      const hasIndexChange = newObservers.some(\n        (observer, index) => observer !== prevObservers[index],\n      )\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return\n      }\n\n      this.observers = newObservers\n      this.observersMap = newObserversMap\n      this.result = newResult\n\n      if (!this.hasListeners()) {\n        return\n      }\n\n      difference(prevObservers, newObservers).forEach((observer) => {\n        observer.destroy()\n      })\n\n      difference(newObservers, prevObservers).forEach((observer) => {\n        observer.subscribe((result) => {\n          this.onUpdate(observer, result)\n        })\n      })\n\n      this.notify()\n    })\n  }\n\n  getCurrentResult(): QueryObserverResult[] {\n    return this.result\n  }\n\n  getQueries() {\n    return this.observers.map((observer) => observer.getCurrentQuery())\n  }\n\n  getOptimisticResult(queries: QueryObserverOptions[]): QueryObserverResult[] {\n    return this.findMatchingObservers(queries).map((match) =>\n      match.observer.getOptimisticResult(match.defaultedQueryOptions),\n    )\n  }\n\n  private findMatchingObservers(\n    queries: QueryObserverOptions[],\n  ): QueryObserverMatch[] {\n    const prevObservers = this.observers\n    const defaultedQueryOptions = queries.map((options) =>\n      this.client.defaultQueryOptions(options),\n    )\n\n    const matchingObservers: QueryObserverMatch[] =\n      defaultedQueryOptions.flatMap((defaultedOptions) => {\n        const match = prevObservers.find(\n          (observer) =>\n            observer.options.queryHash === defaultedOptions.queryHash,\n        )\n        if (match != null) {\n          return [{ defaultedQueryOptions: defaultedOptions, observer: match }]\n        }\n        return []\n      })\n\n    const matchedQueryHashes = matchingObservers.map(\n      (match) => match.defaultedQueryOptions.queryHash,\n    )\n    const unmatchedQueries = defaultedQueryOptions.filter(\n      (defaultedOptions) =>\n        !matchedQueryHashes.includes(defaultedOptions.queryHash),\n    )\n\n    const unmatchedObservers = prevObservers.filter(\n      (prevObserver) =>\n        !matchingObservers.some((match) => match.observer === prevObserver),\n    )\n\n    const getObserver = (options: QueryObserverOptions): QueryObserver => {\n      const defaultedOptions = this.client.defaultQueryOptions(options)\n      const currentObserver = this.observersMap[defaultedOptions.queryHash!]\n      return currentObserver ?? new QueryObserver(this.client, defaultedOptions)\n    }\n\n    const newOrReusedObservers: QueryObserverMatch[] = unmatchedQueries.map(\n      (options, index) => {\n        if (options.keepPreviousData) {\n          // return previous data from one of the observers that no longer match\n          const previouslyUsedObserver = unmatchedObservers[index]\n          if (previouslyUsedObserver !== undefined) {\n            return {\n              defaultedQueryOptions: options,\n              observer: previouslyUsedObserver,\n            }\n          }\n        }\n        return {\n          defaultedQueryOptions: options,\n          observer: getObserver(options),\n        }\n      },\n    )\n\n    const sortMatchesByOrderOfQueries = (\n      a: QueryObserverMatch,\n      b: QueryObserverMatch,\n    ): number =>\n      defaultedQueryOptions.indexOf(a.defaultedQueryOptions) -\n      defaultedQueryOptions.indexOf(b.defaultedQueryOptions)\n\n    return matchingObservers\n      .concat(newOrReusedObservers)\n      .sort(sortMatchesByOrderOfQueries)\n  }\n\n  private onUpdate(observer: QueryObserver, result: QueryObserverResult): void {\n    const index = this.observers.indexOf(observer)\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result)\n      this.notify()\n    }\n  }\n\n  private notify(): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(this.result)\n      })\n    })\n  }\n}\n\ntype QueryObserverMatch = {\n  defaultedQueryOptions: DefaultedQueryObserverOptions\n  observer: QueryObserver\n}\n", "import type {\n  DefaultedInfiniteQueryObserverOptions,\n  FetchNextPageOptions,\n  FetchPreviousPageOptions,\n  InfiniteData,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n  QueryKey,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { NotifyOptions, ObserverFetchOptions } from './queryObserver'\nimport { QueryObserver } from './queryObserver'\nimport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior,\n} from './infiniteQueryBehavior'\nimport type { Query } from './query'\n\ntype InfiniteQueryObserverListener<TData, TError> = (\n  result: InfiniteQueryObserverResult<TData, TError>,\n) => void\n\nexport class InfiniteQueryObserver<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends QueryObserver<\n  TQueryFnData,\n  TError,\n  InfiniteData<TData>,\n  InfiniteData<TQueryData>,\n  TQueryKey\n> {\n  // Type override\n  subscribe!: (\n    listener?: InfiniteQueryObserverListener<TData, TError>,\n  ) => () => void\n\n  // Type override\n  getCurrentResult!: () => InfiniteQueryObserverResult<TData, TError>\n\n  // Type override\n  protected fetch!: (\n    fetchOptions: ObserverFetchOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(\n    client: QueryClient,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super(client, options)\n  }\n\n  protected bindMethods(): void {\n    super.bindMethods()\n    this.fetchNextPage = this.fetchNextPage.bind(this)\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this)\n  }\n\n  setOptions(\n    options?: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    super.setOptions(\n      {\n        ...options,\n        behavior: infiniteQueryBehavior(),\n      },\n      notifyOptions,\n    )\n  }\n\n  getOptimisticResult(\n    options: DefaultedInfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): InfiniteQueryObserverResult<TData, TError> {\n    options.behavior = infiniteQueryBehavior()\n    return super.getOptimisticResult(options) as InfiniteQueryObserverResult<\n      TData,\n      TError\n    >\n  }\n\n  fetchNextPage({ pageParam, ...options }: FetchNextPageOptions = {}): Promise<\n    InfiniteQueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: 'forward', pageParam },\n      },\n    })\n  }\n\n  fetchPreviousPage({\n    pageParam,\n    ...options\n  }: FetchPreviousPageOptions = {}): Promise<\n    InfiniteQueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: 'backward', pageParam },\n      },\n    })\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, InfiniteData<TQueryData>, TQueryKey>,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): InfiniteQueryObserverResult<TData, TError> {\n    const { state } = query\n    const result = super.createResult(query, options)\n    return {\n      ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, state.data?.pages),\n      hasPreviousPage: hasPreviousPage(options, state.data?.pages),\n      isFetchingNextPage:\n        state.fetchStatus === 'fetching' &&\n        state.fetchMeta?.fetchMore?.direction === 'forward',\n      isFetchingPreviousPage:\n        state.fetchStatus === 'fetching' &&\n        state.fetchMeta?.fetchMore?.direction === 'backward',\n    }\n  }\n}\n", "import type { Action, Mutation } from './mutation'\nimport { getDefaultState } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport type { QueryClient } from './queryClient'\nimport { Subscribable } from './subscribable'\nimport type {\n  MutateOptions,\n  MutationObserverBaseResult,\n  MutationObserverResult,\n  MutationObserverOptions,\n} from './types'\nimport { shallowEqualObjects } from './utils'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>,\n) => void\n\ninterface NotifyOptions {\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  private client: QueryClient\n  private currentResult!: MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >\n  private currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  private mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    super()\n\n    this.client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options?: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    const prevOptions = this.options\n    this.options = this.client.defaultMutationOptions(options)\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.currentMutation,\n        observer: this,\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.updateResult()\n\n    // Determine which callbacks to trigger\n    const notifyOptions: NotifyOptions = {\n      listeners: true,\n    }\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true\n    }\n\n    this.notify(notifyOptions)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.currentResult\n  }\n\n  reset(): void {\n    this.currentMutation = undefined\n    this.updateResult()\n    this.notify({ listeners: true })\n  }\n\n  mutate(\n    variables?: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>,\n  ): Promise<TData> {\n    this.mutateOptions = options\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this)\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, {\n      ...this.options,\n      variables:\n        typeof variables !== 'undefined' ? variables : this.options.variables,\n    })\n\n    this.currentMutation.addObserver(this)\n\n    return this.currentMutation.execute()\n  }\n\n  private updateResult(): void {\n    const state = this.currentMutation\n      ? this.currentMutation.state\n      : getDefaultState<TData, TError, TVariables, TContext>()\n\n    const result: MutationObserverBaseResult<\n      TData,\n      TError,\n      TVariables,\n      TContext\n    > = {\n      ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    }\n\n    this.currentResult = result as MutationObserverResult<\n      TData,\n      TError,\n      TVariables,\n      TContext\n    >\n  }\n\n  private notify(options: NotifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions) {\n        if (options.onSuccess) {\n          this.mutateOptions.onSuccess?.(\n            this.currentResult.data!,\n            this.currentResult.variables!,\n            this.currentResult.context!,\n          )\n          this.mutateOptions.onSettled?.(\n            this.currentResult.data!,\n            null,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n        } else if (options.onError) {\n          this.mutateOptions.onError?.(\n            this.currentResult.error!,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n          this.mutateOptions.onSettled?.(\n            undefined,\n            this.currentResult.error,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      if (options.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.currentResult)\n        })\n      }\n    })\n  }\n}\n", "import type { QueryClient } from './queryClient'\nimport type { Query, QueryState } from './query'\nimport type {\n  MutationKey,\n  MutationOptions,\n  QueryKey,\n  QueryOptions,\n} from './types'\nimport type { Mutation, MutationState } from './mutation'\n\n// TYPES\n\nexport interface DehydrateOptions {\n  dehydrateMutations?: boolean\n  dehydrateQueries?: boolean\n  shouldDehydrateMutation?: ShouldDehydrateMutationFunction\n  shouldDehydrateQuery?: ShouldDehydrateQueryFunction\n}\n\nexport interface HydrateOptions {\n  defaultOptions?: {\n    queries?: QueryOptions\n    mutations?: MutationOptions\n  }\n}\n\ninterface DehydratedMutation {\n  mutationKey?: MutationKey\n  state: MutationState\n}\n\ninterface DehydratedQuery {\n  queryHash: string\n  queryKey: QueryKey\n  state: QueryState\n}\n\nexport interface DehydratedState {\n  mutations: DehydratedMutation[]\n  queries: DehydratedQuery[]\n}\n\nexport type ShouldDehydrateQueryFunction = (query: Query) => boolean\n\nexport type ShouldDehydrateMutationFunction = (mutation: Mutation) => boolean\n\n// FUNCTIONS\n\nfunction dehydrateMutation(mutation: Mutation): DehydratedMutation {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n  }\n}\n\n// Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\nfunction dehydrateQuery(query: Query): DehydratedQuery {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n  }\n}\n\nfunction defaultShouldDehydrateMutation(mutation: Mutation) {\n  return mutation.state.isPaused\n}\n\nfunction defaultShouldDehydrateQuery(query: Query) {\n  return query.state.status === 'success'\n}\n\nexport function dehydrate(\n  client: QueryClient,\n  options: DehydrateOptions = {},\n): DehydratedState {\n  const mutations: DehydratedMutation[] = []\n  const queries: DehydratedQuery[] = []\n\n  if (options.dehydrateMutations !== false) {\n    const shouldDehydrateMutation =\n      options.shouldDehydrateMutation || defaultShouldDehydrateMutation\n\n    client\n      .getMutationCache()\n      .getAll()\n      .forEach((mutation) => {\n        if (shouldDehydrateMutation(mutation)) {\n          mutations.push(dehydrateMutation(mutation))\n        }\n      })\n  }\n\n  if (options.dehydrateQueries !== false) {\n    const shouldDehydrateQuery =\n      options.shouldDehydrateQuery || defaultShouldDehydrateQuery\n\n    client\n      .getQueryCache()\n      .getAll()\n      .forEach((query) => {\n        if (shouldDehydrateQuery(query)) {\n          queries.push(dehydrateQuery(query))\n        }\n      })\n  }\n\n  return { mutations, queries }\n}\n\nexport function hydrate(\n  client: QueryClient,\n  dehydratedState: unknown,\n  options?: HydrateOptions,\n): void {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return\n  }\n\n  const mutationCache = client.getMutationCache()\n  const queryCache = client.getQueryCache()\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const mutations = (dehydratedState as DehydratedState).mutations || []\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const queries = (dehydratedState as DehydratedState).queries || []\n\n  mutations.forEach((dehydratedMutation) => {\n    mutationCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.mutations,\n        mutationKey: dehydratedMutation.mutationKey,\n      },\n      dehydratedMutation.state,\n    )\n  })\n\n  queries.forEach((dehydratedQuery) => {\n    const query = queryCache.get(dehydratedQuery.queryHash)\n\n    // Do not hydrate if an existing query exists with newer data\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQuery.state.dataUpdatedAt) {\n        query.setState(dehydratedQuery.state)\n      }\n      return\n    }\n\n    // Restore query\n    queryCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.queries,\n        queryKey: dehydratedQuery.queryKey,\n        queryHash: dehydratedQuery.queryHash,\n      },\n      dehydratedQuery.state,\n    )\n  })\n}\n", "import * as Vue from 'vue'\n\nvar isVue2 = false\nvar isVue3 = true\nvar Vue2 = undefined\n\nfunction install() {}\n\nexport function set(target, key, val) {\n  if (Array.isArray(target)) {\n    target.length = Math.max(target.length, key)\n    target.splice(key, 1, val)\n    return val\n  }\n  target[key] = val\n  return val\n}\n\nexport function del(target, key) {\n  if (Array.isArray(target)) {\n    target.splice(key, 1)\n    return\n  }\n  delete target[key]\n}\n\nexport * from 'vue'\nexport {\n  Vue,\n  Vue2,\n  isVue2,\n  isVue3,\n  install,\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { QueryKey, MutationKey } from '@tanstack/query-core'\nimport { isRef, unref } from 'vue-demi'\nimport type { UnwrapRef } from 'vue-demi'\n\nexport const VUE_QUERY_CLIENT = 'VUE_QUERY_CLIENT'\n\nexport function getClientKey(key?: string) {\n  const suffix = key ? `:${key}` : ''\n  return `${VUE_QUERY_CLIENT}${suffix}`\n}\n\nexport function isQueryKey(value: unknown): value is QueryKey {\n  return Array.isArray(value)\n}\n\nexport function isMutationKey(value: unknown): value is MutationKey {\n  return Array.isArray(value)\n}\n\nexport function updateState(\n  state: Record<string, unknown>,\n  update: Record<string, any>,\n): void {\n  Object.keys(state).forEach((key) => {\n    state[key] = update[key]\n  })\n}\n\nexport function cloneDeep<T>(\n  value: T,\n  customizer?: (val: unknown) => unknown | void,\n): T {\n  if (customizer) {\n    const result = customizer(value)\n    if (result !== undefined || isRef(value)) {\n      return result as typeof value\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return value.map((val) => cloneDeep(val, customizer)) as typeof value\n  }\n\n  if (typeof value === 'object' && isPlainObject(value)) {\n    const entries = Object.entries(value).map(([key, val]) => [\n      key,\n      cloneDeep(val, customizer),\n    ])\n    return Object.fromEntries(entries)\n  }\n\n  return value\n}\n\nexport function cloneDeepUnref<T>(obj: T): UnwrapRef<T> {\n  return cloneDeep(obj, (val) => {\n    if (isRef(val)) {\n      return cloneDeepUnref(unref(val))\n    }\n  }) as UnwrapRef<typeof obj>\n}\n\nfunction isPlainObject(value: unknown): value is Object {\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(value)\n  return prototype === null || prototype === Object.prototype\n}\n", "import { getCurrentInstance, inject } from 'vue-demi'\n\nimport type { QueryClient } from './queryClient'\nimport { getClientKey } from './utils'\n\nexport function useQueryClient(id = ''): QueryClient {\n  const vm = getCurrentInstance()?.proxy\n\n  if (!vm) {\n    throw new Error('vue-query hooks can only be used inside setup() function.')\n  }\n\n  const key = getClientKey(id)\n  const queryClient = inject<QueryClient>(key)\n\n  if (!queryClient) {\n    throw new Error(\n      \"No 'queryClient' found in Vue context, use 'VueQueryPlugin' to properly initialize the library.\",\n    )\n  }\n\n  return queryClient\n}\n", "import { QueryCache as QC } from '@tanstack/query-core'\nimport type { Query, QueryKey, QueryFilters } from '@tanstack/query-core'\nimport type { MaybeRefDeep } from './types'\nimport { cloneDeepUnref, isQueryKey } from './utils'\n\nexport class QueryCache extends QC {\n  find<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    arg1: MaybeRefDeep<QueryKey>,\n    arg2?: MaybeRefDeep<QueryFilters>,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2) as QueryFilters\n    return super.find(arg1Unreffed, arg2Unreffed)\n  }\n\n  findAll(\n    queryKey?: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<QueryFilters>,\n  ): Query[]\n  findAll(filters?: MaybeRefDeep<QueryFilters>): Query[]\n  findAll(\n    arg1?: MaybeRefDeep<QueryKey | QueryFilters>,\n    arg2?: MaybeRefDeep<QueryFilters>,\n  ): Query[]\n  findAll(\n    arg1?: MaybeRefDeep<QueryKey> | MaybeRefDeep<QueryFilters>,\n    arg2?: MaybeRefDeep<QueryFilters>,\n  ): Query[] {\n    const arg1Unreffed = cloneDeepUnref(arg1) as QueryKey | QueryFilters\n    const arg2Unreffed = cloneDeepUnref(arg2) as QueryFilters\n    if (isQueryKey(arg1Unreffed)) {\n      return super.findAll(arg1Unreffed, arg2Unreffed)\n    }\n    return super.findAll(arg1Unreffed)\n  }\n}\n", "import { MutationCache as MC } from '@tanstack/query-core'\nimport type { Mutation, MutationFilters } from '@tanstack/query-core'\nimport type { MaybeRefDeep } from './types'\nimport { cloneDeepUnref } from './utils'\n\nexport class MutationCache extends MC {\n  find<TData = unknown, TError = unknown, TVariables = any, TContext = unknown>(\n    filters: MaybeRefDeep<MutationFilters>,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    return super.find(cloneDeepUnref(filters) as MutationFilters)\n  }\n\n  findAll(filters: MaybeRefDeep<MutationFilters>): Mutation[] {\n    return super.findAll(cloneDeepUnref(filters) as MutationFilters)\n  }\n}\n", "import { QueryClient as QC } from '@tanstack/query-core'\nimport type {\n  QueryKey,\n  QueryClientConfig,\n  SetDataOptions,\n  ResetQueryFilters,\n  ResetOptions,\n  CancelOptions,\n  InvalidateQueryFilters,\n  InvalidateOptions,\n  RefetchQueryFilters,\n  RefetchOptions,\n  FetchQueryOptions,\n  QueryFunction,\n  FetchInfiniteQueryOptions,\n  InfiniteData,\n  DefaultOptions,\n  QueryObserverOptions,\n  MutationKey,\n  MutationObserverOptions,\n  QueryFilters,\n  MutationFilters,\n  QueryState,\n  Updater,\n} from '@tanstack/query-core'\nimport type { MaybeRefDeep } from './types'\nimport { cloneDeepUnref, isQueryKey } from './utils'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\n\nexport class QueryClient extends QC {\n  constructor(config: MaybeRefDeep<QueryClientConfig> = {}) {\n    const unreffedConfig = cloneDeepUnref(config) as QueryClientConfig\n    const vueQueryConfig: QueryClientConfig = {\n      logger: cloneDeepUnref(unreffedConfig.logger),\n      defaultOptions: cloneDeepUnref(unreffedConfig.defaultOptions),\n      queryCache: unreffedConfig.queryCache || new QueryCache(),\n      mutationCache: unreffedConfig.mutationCache || new MutationCache(),\n    }\n    super(vueQueryConfig)\n  }\n\n  isFetching(filters?: MaybeRefDeep<QueryFilters>): number\n  isFetching(\n    queryKey?: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<QueryFilters>,\n  ): number\n  isFetching(\n    arg1?: MaybeRefDeep<QueryFilters | QueryKey>,\n    arg2?: MaybeRefDeep<QueryFilters>,\n  ): number {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2) as QueryFilters\n    if (isQueryKey(arg1Unreffed)) {\n      return super.isFetching(arg1Unreffed, arg2Unreffed)\n    }\n    return super.isFetching(arg1Unreffed as QueryFilters)\n  }\n\n  isMutating(filters?: MaybeRefDeep<MutationFilters>): number {\n    return super.isMutating(cloneDeepUnref(filters) as MutationFilters)\n  }\n\n  getQueryData<TData = unknown>(\n    queryKey: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<QueryFilters>,\n  ): TData | undefined {\n    return super.getQueryData(\n      cloneDeepUnref(queryKey),\n      cloneDeepUnref(filters) as QueryFilters,\n    )\n  }\n\n  getQueriesData<TData = unknown>(\n    queryKey: MaybeRefDeep<QueryKey>,\n  ): [QueryKey, TData | undefined][]\n  getQueriesData<TData = unknown>(\n    filters: MaybeRefDeep<QueryFilters>,\n  ): [QueryKey, TData | undefined][]\n  getQueriesData<TData = unknown>(\n    queryKeyOrFilters: MaybeRefDeep<QueryKey> | MaybeRefDeep<QueryFilters>,\n  ): [QueryKey, TData | undefined][] {\n    const unreffed = cloneDeepUnref(queryKeyOrFilters)\n    if (isQueryKey(unreffed)) {\n      return super.getQueriesData(unreffed)\n    }\n    return super.getQueriesData(unreffed as QueryFilters)\n  }\n\n  setQueryData<TData>(\n    queryKey: MaybeRefDeep<QueryKey>,\n    updater: Updater<TData | undefined, TData | undefined>,\n    options?: MaybeRefDeep<SetDataOptions>,\n  ): TData | undefined {\n    return super.setQueryData(\n      cloneDeepUnref(queryKey),\n      updater,\n      cloneDeepUnref(options) as SetDataOptions,\n    )\n  }\n\n  setQueriesData<TData>(\n    queryKey: MaybeRefDeep<QueryKey>,\n    updater: Updater<TData | undefined, TData | undefined>,\n    options?: MaybeRefDeep<SetDataOptions>,\n  ): [QueryKey, TData | undefined][]\n  setQueriesData<TData>(\n    filters: MaybeRefDeep<QueryFilters>,\n    updater: Updater<TData | undefined, TData | undefined>,\n    options?: MaybeRefDeep<SetDataOptions>,\n  ): [QueryKey, TData | undefined][]\n  setQueriesData<TData>(\n    queryKeyOrFilters: MaybeRefDeep<QueryKey | QueryFilters>,\n    updater: Updater<TData | undefined, TData | undefined>,\n    options?: MaybeRefDeep<SetDataOptions>,\n  ): [QueryKey, TData | undefined][] {\n    const arg1Unreffed = cloneDeepUnref(queryKeyOrFilters)\n    const arg3Unreffed = cloneDeepUnref(options) as SetDataOptions\n    if (isQueryKey(arg1Unreffed)) {\n      return super.setQueriesData(arg1Unreffed, updater, arg3Unreffed)\n    }\n    return super.setQueriesData(\n      arg1Unreffed as QueryFilters,\n      updater,\n      arg3Unreffed,\n    )\n  }\n\n  getQueryState<TData = unknown, TError = undefined>(\n    queryKey: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<QueryFilters>,\n  ): QueryState<TData, TError> | undefined {\n    return super.getQueryState(\n      cloneDeepUnref(queryKey),\n      cloneDeepUnref(filters) as QueryFilters,\n    )\n  }\n\n  removeQueries(filters?: MaybeRefDeep<QueryFilters>): void\n  removeQueries(\n    queryKey?: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<QueryFilters>,\n  ): void\n  removeQueries(\n    arg1?: MaybeRefDeep<QueryKey | QueryFilters>,\n    arg2?: MaybeRefDeep<QueryFilters>,\n  ): void {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    if (isQueryKey(arg1Unreffed)) {\n      return super.removeQueries(\n        arg1Unreffed,\n        cloneDeepUnref(arg2) as QueryFilters,\n      )\n    }\n    return super.removeQueries(arg1Unreffed as QueryFilters)\n  }\n\n  resetQueries<TPageData = unknown>(\n    filters?: MaybeRefDeep<ResetQueryFilters<TPageData>>,\n    options?: MaybeRefDeep<ResetOptions>,\n  ): Promise<void>\n  resetQueries<TPageData = unknown>(\n    queryKey?: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<ResetQueryFilters<TPageData>>,\n    options?: MaybeRefDeep<ResetOptions>,\n  ): Promise<void>\n  resetQueries<TPageData = unknown>(\n    arg1?: MaybeRefDeep<QueryKey | ResetQueryFilters<TPageData>>,\n    arg2?: MaybeRefDeep<ResetQueryFilters<TPageData> | ResetOptions>,\n    arg3?: MaybeRefDeep<ResetOptions>,\n  ): Promise<void> {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2)\n    if (isQueryKey(arg1Unreffed)) {\n      return super.resetQueries(\n        arg1Unreffed,\n        arg2Unreffed as ResetQueryFilters<TPageData> | undefined,\n        cloneDeepUnref(arg3) as ResetOptions,\n      )\n    }\n    return super.resetQueries(\n      arg1Unreffed as ResetQueryFilters<TPageData>,\n      arg2Unreffed as ResetOptions,\n    )\n  }\n\n  cancelQueries(\n    filters?: MaybeRefDeep<QueryFilters>,\n    options?: MaybeRefDeep<CancelOptions>,\n  ): Promise<void>\n  cancelQueries(\n    queryKey?: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<QueryFilters>,\n    options?: MaybeRefDeep<CancelOptions>,\n  ): Promise<void>\n  cancelQueries(\n    arg1?: MaybeRefDeep<QueryKey | QueryFilters>,\n    arg2?: MaybeRefDeep<QueryFilters | CancelOptions>,\n    arg3?: MaybeRefDeep<CancelOptions>,\n  ): Promise<void> {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2)\n    if (isQueryKey(arg1Unreffed)) {\n      return super.cancelQueries(\n        arg1Unreffed,\n        arg2Unreffed as QueryFilters | undefined,\n        cloneDeepUnref(arg3) as CancelOptions,\n      )\n    }\n    return super.cancelQueries(\n      arg1Unreffed as QueryFilters,\n      arg2Unreffed as CancelOptions,\n    )\n  }\n\n  invalidateQueries<TPageData = unknown>(\n    filters?: MaybeRefDeep<InvalidateQueryFilters<TPageData>>,\n    options?: MaybeRefDeep<InvalidateOptions>,\n  ): Promise<void>\n  invalidateQueries<TPageData = unknown>(\n    queryKey?: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<InvalidateQueryFilters<TPageData>>,\n    options?: MaybeRefDeep<InvalidateOptions>,\n  ): Promise<void>\n  invalidateQueries<TPageData = unknown>(\n    arg1?: MaybeRefDeep<QueryKey | InvalidateQueryFilters<TPageData>>,\n    arg2?: MaybeRefDeep<InvalidateQueryFilters<TPageData> | InvalidateOptions>,\n    arg3?: MaybeRefDeep<InvalidateOptions>,\n  ): Promise<void> {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2)\n    if (isQueryKey(arg1Unreffed)) {\n      return super.invalidateQueries(\n        arg1Unreffed,\n        arg2Unreffed as InvalidateQueryFilters | undefined,\n        cloneDeepUnref(arg3) as InvalidateOptions,\n      )\n    }\n    return super.invalidateQueries(\n      arg1Unreffed as InvalidateQueryFilters<TPageData>,\n      arg2Unreffed as InvalidateOptions,\n    )\n  }\n\n  refetchQueries<TPageData = unknown>(\n    filters?: MaybeRefDeep<RefetchQueryFilters<TPageData>>,\n    options?: MaybeRefDeep<RefetchOptions>,\n  ): Promise<void>\n  refetchQueries<TPageData = unknown>(\n    queryKey?: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<RefetchQueryFilters<TPageData>>,\n    options?: MaybeRefDeep<RefetchOptions>,\n  ): Promise<void>\n  refetchQueries<TPageData = unknown>(\n    arg1?: MaybeRefDeep<QueryKey | RefetchQueryFilters<TPageData>>,\n    arg2?: MaybeRefDeep<RefetchQueryFilters<TPageData> | RefetchOptions>,\n    arg3?: MaybeRefDeep<RefetchOptions>,\n  ): Promise<void> {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2)\n    if (isQueryKey(arg1Unreffed)) {\n      return super.refetchQueries(\n        arg1Unreffed,\n        arg2Unreffed as RefetchQueryFilters | undefined,\n        cloneDeepUnref(arg3) as RefetchOptions,\n      )\n    }\n    return super.refetchQueries(\n      arg1Unreffed as RefetchQueryFilters<TPageData>,\n      arg2Unreffed as RefetchOptions,\n    )\n  }\n\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | MaybeRefDeep<TQueryKey>\n      | MaybeRefDeep<FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | MaybeRefDeep<FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>>,\n    arg3?: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<TData> {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2)\n    if (isQueryKey(arg1Unreffed)) {\n      return super.fetchQuery(\n        arg1Unreffed as TQueryKey,\n        arg2Unreffed as QueryFunction<TQueryFnData, TQueryKey>,\n        cloneDeepUnref(arg3) as FetchQueryOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryKey\n        >,\n      )\n    }\n    return super.fetchQuery(\n      arg1Unreffed as FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    )\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: MaybeRefDeep<\n      TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | MaybeRefDeep<FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>>,\n    arg3?: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void> {\n    return super.prefetchQuery(\n      cloneDeepUnref(arg1) as any,\n      cloneDeepUnref(arg2) as any,\n      cloneDeepUnref(arg3) as any,\n    )\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: MaybeRefDeep<\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | MaybeRefDeep<\n          FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n        >,\n    arg3?: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<InfiniteData<TData>> {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2)\n    if (isQueryKey(arg1Unreffed)) {\n      return super.fetchInfiniteQuery(\n        arg1Unreffed as TQueryKey,\n        arg2Unreffed as QueryFunction<TQueryFnData, TQueryKey>,\n        cloneDeepUnref(arg3) as FetchInfiniteQueryOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryKey\n        >,\n      )\n    }\n    return super.fetchInfiniteQuery(\n      arg1Unreffed as FetchInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryKey\n      >,\n    )\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: MaybeRefDeep<\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | MaybeRefDeep<\n          FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n        >,\n    arg3?: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void> {\n    return super.prefetchInfiniteQuery(\n      cloneDeepUnref(arg1) as any,\n      cloneDeepUnref(arg2) as any,\n      cloneDeepUnref(arg3) as any,\n    )\n  }\n\n  setDefaultOptions(options: MaybeRefDeep<DefaultOptions>): void {\n    super.setDefaultOptions(cloneDeepUnref(options) as DefaultOptions)\n  }\n\n  setQueryDefaults(\n    queryKey: MaybeRefDeep<QueryKey>,\n    options: MaybeRefDeep<QueryObserverOptions<any, any, any, any>>,\n  ): void {\n    super.setQueryDefaults(\n      cloneDeepUnref(queryKey),\n      cloneDeepUnref(options) as any,\n    )\n  }\n\n  getQueryDefaults(\n    queryKey?: MaybeRefDeep<QueryKey>,\n  ): QueryObserverOptions<any, any, any, any, any> | undefined {\n    return super.getQueryDefaults(cloneDeepUnref(queryKey))\n  }\n\n  setMutationDefaults(\n    mutationKey: MaybeRefDeep<MutationKey>,\n    options: MaybeRefDeep<MutationObserverOptions<any, any, any, any>>,\n  ): void {\n    super.setMutationDefaults(\n      cloneDeepUnref(mutationKey),\n      cloneDeepUnref(options) as any,\n    )\n  }\n\n  getMutationDefaults(\n    mutationKey?: MaybeRefDeep<MutationKey>,\n  ): MutationObserverOptions<any, any, any, any> | undefined {\n    return super.getMutationDefaults(cloneDeepUnref(mutationKey))\n  }\n}\n", "const characterMap: Record<string, string> = {\n  \u00C0: 'A',\n  \u00C1: 'A',\n  \u00C2: 'A',\n  \u00C3: 'A',\n  \u00C4: 'A',\n  \u00C5: 'A',\n  \u1EA4: 'A',\n  \u1EAE: 'A',\n  \u1EB2: 'A',\n  \u1EB4: 'A',\n  \u1EB6: 'A',\n  \u00C6: 'AE',\n  \u1EA6: 'A',\n  \u1EB0: 'A',\n  \u0202: 'A',\n  \u00C7: 'C',\n  \u1E08: 'C',\n  \u00C8: 'E',\n  \u00C9: 'E',\n  \u00CA: 'E',\n  \u00CB: 'E',\n  \u1EBE: 'E',\n  \u1E16: 'E',\n  \u1EC0: 'E',\n  \u1E14: 'E',\n  \u1E1C: 'E',\n  \u0206: 'E',\n  \u00CC: 'I',\n  \u00CD: 'I',\n  \u00CE: 'I',\n  \u00CF: 'I',\n  \u1E2E: 'I',\n  \u020A: 'I',\n  \u00D0: 'D',\n  \u00D1: 'N',\n  \u00D2: 'O',\n  \u00D3: 'O',\n  \u00D4: 'O',\n  \u00D5: 'O',\n  \u00D6: 'O',\n  \u00D8: 'O',\n  \u1ED0: 'O',\n  \u1E4C: 'O',\n  \u1E52: 'O',\n  \u020E: 'O',\n  \u00D9: 'U',\n  \u00DA: 'U',\n  \u00DB: 'U',\n  \u00DC: 'U',\n  \u00DD: 'Y',\n  \u00E0: 'a',\n  \u00E1: 'a',\n  \u00E2: 'a',\n  \u00E3: 'a',\n  \u00E4: 'a',\n  \u00E5: 'a',\n  \u1EA5: 'a',\n  \u1EAF: 'a',\n  \u1EB3: 'a',\n  \u1EB5: 'a',\n  \u1EB7: 'a',\n  \u00E6: 'ae',\n  \u1EA7: 'a',\n  \u1EB1: 'a',\n  \u0203: 'a',\n  \u00E7: 'c',\n  \u1E09: 'c',\n  \u00E8: 'e',\n  \u00E9: 'e',\n  \u00EA: 'e',\n  \u00EB: 'e',\n  \u1EBF: 'e',\n  \u1E17: 'e',\n  \u1EC1: 'e',\n  \u1E15: 'e',\n  \u1E1D: 'e',\n  \u0207: 'e',\n  \u00EC: 'i',\n  \u00ED: 'i',\n  \u00EE: 'i',\n  \u00EF: 'i',\n  \u1E2F: 'i',\n  \u020B: 'i',\n  \u00F0: 'd',\n  \u00F1: 'n',\n  \u00F2: 'o',\n  \u00F3: 'o',\n  \u00F4: 'o',\n  \u00F5: 'o',\n  \u00F6: 'o',\n  \u00F8: 'o',\n  \u1ED1: 'o',\n  \u1E4D: 'o',\n  \u1E53: 'o',\n  \u020F: 'o',\n  \u00F9: 'u',\n  \u00FA: 'u',\n  \u00FB: 'u',\n  \u00FC: 'u',\n  \u00FD: 'y',\n  \u00FF: 'y',\n  \u0100: 'A',\n  \u0101: 'a',\n  \u0102: 'A',\n  \u0103: 'a',\n  \u0104: 'A',\n  \u0105: 'a',\n  \u0106: 'C',\n  \u0107: 'c',\n  \u0108: 'C',\n  \u0109: 'c',\n  \u010A: 'C',\n  \u010B: 'c',\n  \u010C: 'C',\n  \u010D: 'c',\n  C\u0306: 'C',\n  c\u0306: 'c',\n  \u010E: 'D',\n  \u010F: 'd',\n  \u0110: 'D',\n  \u0111: 'd',\n  \u0112: 'E',\n  \u0113: 'e',\n  \u0114: 'E',\n  \u0115: 'e',\n  \u0116: 'E',\n  \u0117: 'e',\n  \u0118: 'E',\n  \u0119: 'e',\n  \u011A: 'E',\n  \u011B: 'e',\n  \u011C: 'G',\n  \u01F4: 'G',\n  \u011D: 'g',\n  \u01F5: 'g',\n  \u011E: 'G',\n  \u011F: 'g',\n  \u0120: 'G',\n  \u0121: 'g',\n  \u0122: 'G',\n  \u0123: 'g',\n  \u0124: 'H',\n  \u0125: 'h',\n  \u0126: 'H',\n  \u0127: 'h',\n  \u1E2A: 'H',\n  \u1E2B: 'h',\n  \u0128: 'I',\n  \u0129: 'i',\n  \u012A: 'I',\n  \u012B: 'i',\n  \u012C: 'I',\n  \u012D: 'i',\n  \u012E: 'I',\n  \u012F: 'i',\n  \u0130: 'I',\n  \u0131: 'i',\n  \u0132: 'IJ',\n  \u0133: 'ij',\n  \u0134: 'J',\n  \u0135: 'j',\n  \u0136: 'K',\n  \u0137: 'k',\n  \u1E30: 'K',\n  \u1E31: 'k',\n  K\u0306: 'K',\n  k\u0306: 'k',\n  \u0139: 'L',\n  \u013A: 'l',\n  \u013B: 'L',\n  \u013C: 'l',\n  \u013D: 'L',\n  \u013E: 'l',\n  \u013F: 'L',\n  \u0140: 'l',\n  \u0141: 'l',\n  \u0142: 'l',\n  \u1E3E: 'M',\n  \u1E3F: 'm',\n  M\u0306: 'M',\n  m\u0306: 'm',\n  \u0143: 'N',\n  \u0144: 'n',\n  \u0145: 'N',\n  \u0146: 'n',\n  \u0147: 'N',\n  \u0148: 'n',\n  \u0149: 'n',\n  N\u0306: 'N',\n  n\u0306: 'n',\n  \u014C: 'O',\n  \u014D: 'o',\n  \u014E: 'O',\n  \u014F: 'o',\n  \u0150: 'O',\n  \u0151: 'o',\n  \u0152: 'OE',\n  \u0153: 'oe',\n  P\u0306: 'P',\n  p\u0306: 'p',\n  \u0154: 'R',\n  \u0155: 'r',\n  \u0156: 'R',\n  \u0157: 'r',\n  \u0158: 'R',\n  \u0159: 'r',\n  R\u0306: 'R',\n  r\u0306: 'r',\n  \u0212: 'R',\n  \u0213: 'r',\n  \u015A: 'S',\n  \u015B: 's',\n  \u015C: 'S',\n  \u015D: 's',\n  \u015E: 'S',\n  \u0218: 'S',\n  \u0219: 's',\n  \u015F: 's',\n  \u0160: 'S',\n  \u0161: 's',\n  \u0162: 'T',\n  \u0163: 't',\n  \u021B: 't',\n  \u021A: 'T',\n  \u0164: 'T',\n  \u0165: 't',\n  \u0166: 'T',\n  \u0167: 't',\n  T\u0306: 'T',\n  t\u0306: 't',\n  \u0168: 'U',\n  \u0169: 'u',\n  \u016A: 'U',\n  \u016B: 'u',\n  \u016C: 'U',\n  \u016D: 'u',\n  \u016E: 'U',\n  \u016F: 'u',\n  \u0170: 'U',\n  \u0171: 'u',\n  \u0172: 'U',\n  \u0173: 'u',\n  \u0216: 'U',\n  \u0217: 'u',\n  V\u0306: 'V',\n  v\u0306: 'v',\n  \u0174: 'W',\n  \u0175: 'w',\n  \u1E82: 'W',\n  \u1E83: 'w',\n  X\u0306: 'X',\n  x\u0306: 'x',\n  \u0176: 'Y',\n  \u0177: 'y',\n  \u0178: 'Y',\n  Y\u0306: 'Y',\n  y\u0306: 'y',\n  \u0179: 'Z',\n  \u017A: 'z',\n  \u017B: 'Z',\n  \u017C: 'z',\n  \u017D: 'Z',\n  \u017E: 'z',\n  \u017F: 's',\n  \u0192: 'f',\n  \u01A0: 'O',\n  \u01A1: 'o',\n  \u01AF: 'U',\n  \u01B0: 'u',\n  \u01CD: 'A',\n  \u01CE: 'a',\n  \u01CF: 'I',\n  \u01D0: 'i',\n  \u01D1: 'O',\n  \u01D2: 'o',\n  \u01D3: 'U',\n  \u01D4: 'u',\n  \u01D5: 'U',\n  \u01D6: 'u',\n  \u01D7: 'U',\n  \u01D8: 'u',\n  \u01D9: 'U',\n  \u01DA: 'u',\n  \u01DB: 'U',\n  \u01DC: 'u',\n  \u1EE8: 'U',\n  \u1EE9: 'u',\n  \u1E78: 'U',\n  \u1E79: 'u',\n  \u01FA: 'A',\n  \u01FB: 'a',\n  \u01FC: 'AE',\n  \u01FD: 'ae',\n  \u01FE: 'O',\n  \u01FF: 'o',\n  \u00DE: 'TH',\n  \u00FE: 'th',\n  \u1E54: 'P',\n  \u1E55: 'p',\n  \u1E64: 'S',\n  \u1E65: 's',\n  X\u0301: 'X',\n  x\u0301: 'x',\n  \u0403: '\u0413',\n  \u0453: '\u0433',\n  \u040C: '\u041A',\n  \u045C: '\u043A',\n  A\u030B: 'A',\n  a\u030B: 'a',\n  E\u030B: 'E',\n  e\u030B: 'e',\n  I\u030B: 'I',\n  i\u030B: 'i',\n  \u01F8: 'N',\n  \u01F9: 'n',\n  \u1ED2: 'O',\n  \u1ED3: 'o',\n  \u1E50: 'O',\n  \u1E51: 'o',\n  \u1EEA: 'U',\n  \u1EEB: 'u',\n  \u1E80: 'W',\n  \u1E81: 'w',\n  \u1EF2: 'Y',\n  \u1EF3: 'y',\n  \u0200: 'A',\n  \u0201: 'a',\n  \u0204: 'E',\n  \u0205: 'e',\n  \u0208: 'I',\n  \u0209: 'i',\n  \u020C: 'O',\n  \u020D: 'o',\n  \u0210: 'R',\n  \u0211: 'r',\n  \u0214: 'U',\n  \u0215: 'u',\n  B\u030C: 'B',\n  b\u030C: 'b',\n  \u010C\u0323: 'C',\n  \u010D\u0323: 'c',\n  \u00CA\u030C: 'E',\n  \u00EA\u030C: 'e',\n  F\u030C: 'F',\n  f\u030C: 'f',\n  \u01E6: 'G',\n  \u01E7: 'g',\n  \u021E: 'H',\n  \u021F: 'h',\n  J\u030C: 'J',\n  \u01F0: 'j',\n  \u01E8: 'K',\n  \u01E9: 'k',\n  M\u030C: 'M',\n  m\u030C: 'm',\n  P\u030C: 'P',\n  p\u030C: 'p',\n  Q\u030C: 'Q',\n  q\u030C: 'q',\n  \u0158\u0329: 'R',\n  \u0159\u0329: 'r',\n  \u1E66: 'S',\n  \u1E67: 's',\n  V\u030C: 'V',\n  v\u030C: 'v',\n  W\u030C: 'W',\n  w\u030C: 'w',\n  X\u030C: 'X',\n  x\u030C: 'x',\n  Y\u030C: 'Y',\n  y\u030C: 'y',\n  A\u0327: 'A',\n  a\u0327: 'a',\n  B\u0327: 'B',\n  b\u0327: 'b',\n  \u1E10: 'D',\n  \u1E11: 'd',\n  \u0228: 'E',\n  \u0229: 'e',\n  \u0190\u0327: 'E',\n  \u025B\u0327: 'e',\n  \u1E28: 'H',\n  \u1E29: 'h',\n  I\u0327: 'I',\n  i\u0327: 'i',\n  \u0197\u0327: 'I',\n  \u0268\u0327: 'i',\n  M\u0327: 'M',\n  m\u0327: 'm',\n  O\u0327: 'O',\n  o\u0327: 'o',\n  Q\u0327: 'Q',\n  q\u0327: 'q',\n  U\u0327: 'U',\n  u\u0327: 'u',\n  X\u0327: 'X',\n  x\u0327: 'x',\n  Z\u0327: 'Z',\n  z\u0327: 'z',\n}\n\nconst chars = Object.keys(characterMap).join('|')\nconst allAccents = new RegExp(chars, 'g')\n\nexport function removeAccents(str: string) {\n  return str.replace(allAccents, match => {\n    return characterMap[match]!\n  })\n}\n", "/**\n * @name match-sorter\n * @license MIT license.\n * @copyright (c) 2099 Kent C. Dodds\n * @author Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)\n */\n\n// This is a fork of match-sorter. Instead of offering\n// a unified API for filtering and sorting in a single pass,\n// match-sorter-utils provides the lower-level utilities of\n// ranking items and comparing ranks in a way that can\n// be incrementally applied to a system rather than\n// all-at-once.\n\n// 1. Use the rankItem function to rank an item\n// 2. Use the resulting rankingInfo.passed to filter\n// 3. Use the resulting rankingInfo.rank to sort\n\n// For bundling purposes (mainly remove-accents not being esm safe/ready),\n// we've also hard-coded remove-accents into this source.\n// The remove-accents package is still included as a dependency\n// for attribution purposes, but it will not be imported and bundled.\n\nimport { removeAccents } from './remove-accents'\n\nexport type AccessorAttributes = {\n  threshold?: Ranking\n  maxRanking: Ranking\n  minRanking: Ranking\n}\n\nexport interface RankingInfo {\n  rankedValue: any\n  rank: Ranking\n  accessorIndex: number\n  accessorThreshold: Ranking | undefined\n  passed: boolean\n}\n\nexport interface AccessorOptions<TItem> {\n  accessor: AccessorFn<TItem>\n  threshold?: Ranking\n  maxRanking?: Ranking\n  minRanking?: Ranking\n}\n\nexport type AccessorFn<TItem> = (item: TItem) => string | Array<string>\n\nexport type Accessor<TItem> = AccessorFn<TItem> | AccessorOptions<TItem>\n\nexport interface RankItemOptions<TItem = unknown> {\n  accessors?: ReadonlyArray<Accessor<TItem>>\n  threshold?: Ranking\n  keepDiacritics?: boolean\n}\n\nexport const rankings = {\n  CASE_SENSITIVE_EQUAL: 7,\n  EQUAL: 6,\n  STARTS_WITH: 5,\n  WORD_STARTS_WITH: 4,\n  CONTAINS: 3,\n  ACRONYM: 2,\n  MATCHES: 1,\n  NO_MATCH: 0,\n} as const\n\nexport type Ranking = typeof rankings[keyof typeof rankings]\n\n/**\n * Gets the highest ranking for value for the given item based on its values for the given keys\n * @param {*} item - the item to rank\n * @param {Array} keys - the keys to get values from the item for the ranking\n * @param {String} value - the value to rank against\n * @param {Object} options - options to control the ranking\n * @return {{rank: Number, accessorIndex: Number, accessorThreshold: Number}} - the highest ranking\n */\nexport function rankItem<TItem>(\n  item: TItem,\n  value: string,\n  options?: RankItemOptions<TItem>\n): RankingInfo {\n  options = options || {}\n\n  options.threshold = options.threshold ?? rankings.MATCHES\n\n  if (!options.accessors) {\n    // if keys is not specified, then we assume the item given is ready to be matched\n    const rank = getMatchRanking(item as unknown as string, value, options)\n    return {\n      // ends up being duplicate of 'item' in matches but consistent\n      rankedValue: item,\n      rank,\n      accessorIndex: -1,\n      accessorThreshold: options.threshold,\n      passed: rank >= options.threshold,\n    }\n  }\n\n  const valuesToRank = getAllValuesToRank(item, options.accessors)\n\n  const rankingInfo: RankingInfo = {\n    rankedValue: item,\n    rank: rankings.NO_MATCH as Ranking,\n    accessorIndex: -1,\n    accessorThreshold: options.threshold,\n    passed: false,\n  }\n\n  for (let i = 0; i < valuesToRank.length; i++) {\n    const rankValue = valuesToRank[i]!\n\n    let newRank = getMatchRanking(rankValue.itemValue, value, options)\n\n    const { minRanking, maxRanking, threshold = options.threshold } = rankValue.attributes\n\n    if (newRank < minRanking && newRank >= rankings.MATCHES) {\n      newRank = minRanking\n    } else if (newRank > maxRanking) {\n      newRank = maxRanking\n    }\n\n    newRank = Math.min(newRank, maxRanking) as Ranking\n\n    if (newRank >= threshold && newRank > rankingInfo.rank) {\n      rankingInfo.rank = newRank\n      rankingInfo.passed = true\n      rankingInfo.accessorIndex = i\n      rankingInfo.accessorThreshold = threshold\n      rankingInfo.rankedValue = rankValue.itemValue\n    }\n  }\n\n  return rankingInfo\n}\n\n/**\n * Gives a rankings score based on how well the two strings match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Object} options - options for the match (like keepDiacritics for comparison)\n * @returns {Number} the ranking for how well stringToRank matches testString\n */\nfunction getMatchRanking<TItem>(\n  testString: string,\n  stringToRank: string,\n  options: RankItemOptions<TItem>\n): Ranking {\n  testString = prepareValueForComparison(testString, options)\n  stringToRank = prepareValueForComparison(stringToRank, options)\n\n  // too long\n  if (stringToRank.length > testString.length) {\n    return rankings.NO_MATCH\n  }\n\n  // case sensitive equals\n  if (testString === stringToRank) {\n    return rankings.CASE_SENSITIVE_EQUAL\n  }\n\n  // Lower casing before further comparison\n  testString = testString.toLowerCase()\n  stringToRank = stringToRank.toLowerCase()\n\n  // case insensitive equals\n  if (testString === stringToRank) {\n    return rankings.EQUAL\n  }\n\n  // starts with\n  if (testString.startsWith(stringToRank)) {\n    return rankings.STARTS_WITH\n  }\n\n  // word starts with\n  if (testString.includes(` ${stringToRank}`)) {\n    return rankings.WORD_STARTS_WITH\n  }\n\n  // contains\n  if (testString.includes(stringToRank)) {\n    return rankings.CONTAINS\n  } else if (stringToRank.length === 1) {\n    // If the only character in the given stringToRank\n    //   isn't even contained in the testString, then\n    //   it's definitely not a match.\n    return rankings.NO_MATCH\n  }\n\n  // acronym\n  if (getAcronym(testString).includes(stringToRank)) {\n    return rankings.ACRONYM\n  }\n\n  // will return a number between rankings.MATCHES and\n  // rankings.MATCHES + 1 depending  on how close of a match it is.\n  return getClosenessRanking(testString, stringToRank)\n}\n\n/**\n * Generates an acronym for a string.\n *\n * @param {String} string the string for which to produce the acronym\n * @returns {String} the acronym\n */\nfunction getAcronym(string: string): string {\n  let acronym = ''\n  const wordsInString = string.split(' ')\n  wordsInString.forEach(wordInString => {\n    const splitByHyphenWords = wordInString.split('-')\n    splitByHyphenWords.forEach(splitByHyphenWord => {\n      acronym += splitByHyphenWord.substr(0, 1)\n    })\n  })\n  return acronym\n}\n\n/**\n * Returns a score based on how spread apart the\n * characters from the stringToRank are within the testString.\n * A number close to rankings.MATCHES represents a loose match. A number close\n * to rankings.MATCHES + 1 represents a tighter match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @returns {Number} the number between rankings.MATCHES and\n * rankings.MATCHES + 1 for how well stringToRank matches testString\n */\nfunction getClosenessRanking(\n  testString: string,\n  stringToRank: string\n): Ranking {\n  let matchingInOrderCharCount = 0\n  let charNumber = 0\n  function findMatchingCharacter(\n    matchChar: undefined | string,\n    string: string,\n    index: number\n  ) {\n    for (let j = index, J = string.length; j < J; j++) {\n      const stringChar = string[j]\n      if (stringChar === matchChar) {\n        matchingInOrderCharCount += 1\n        return j + 1\n      }\n    }\n    return -1\n  }\n  function getRanking(spread: number) {\n    const spreadPercentage = 1 / spread\n    const inOrderPercentage = matchingInOrderCharCount / stringToRank.length\n    const ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage\n    return ranking as Ranking\n  }\n  const firstIndex = findMatchingCharacter(stringToRank[0], testString, 0)\n  if (firstIndex < 0) {\n    return rankings.NO_MATCH\n  }\n  charNumber = firstIndex\n  for (let i = 1, I = stringToRank.length; i < I; i++) {\n    const matchChar = stringToRank[i]\n    charNumber = findMatchingCharacter(matchChar, testString, charNumber)\n    const found = charNumber > -1\n    if (!found) {\n      return rankings.NO_MATCH\n    }\n  }\n\n  const spread = charNumber - firstIndex\n  return getRanking(spread)\n}\n\n/**\n * Sorts items that have a rank, index, and accessorIndex\n * @param {Object} a - the first item to sort\n * @param {Object} b - the second item to sort\n * @return {Number} -1 if a should come first, 1 if b should come first, 0 if equal\n */\nexport function compareItems<TItem>(a: RankingInfo, b: RankingInfo): number {\n  return a.rank === b.rank ? 0 : a.rank > b.rank ? -1 : 1\n}\n\n/**\n * Prepares value for comparison by stringifying it, removing diacritics (if specified)\n * @param {String} value - the value to clean\n * @param {Object} options - {keepDiacritics: whether to remove diacritics}\n * @return {String} the prepared value\n */\nfunction prepareValueForComparison<TItem>(\n  value: string,\n  { keepDiacritics }: RankItemOptions<TItem>\n): string {\n  // value might not actually be a string at this point (we don't get to choose)\n  // so part of preparing the value for comparison is ensure that it is a string\n  value = `${value}` // toString\n  if (!keepDiacritics) {\n    value = removeAccents(value)\n  }\n  return value\n}\n\n/**\n * Gets value for key in item at arbitrarily nested keypath\n * @param {Object} item - the item\n * @param {Object|Function} key - the potentially nested keypath or property callback\n * @return {Array} - an array containing the value(s) at the nested keypath\n */\nfunction getItemValues<TItem>(\n  item: TItem,\n  accessor: Accessor<TItem>\n): Array<string> {\n  let accessorFn = accessor as AccessorFn<TItem>\n\n  if (typeof accessor === 'object') {\n    accessorFn = accessor.accessor\n  }\n\n  const value = accessorFn(item)\n\n  // because `value` can also be undefined\n  if (value == null) {\n    return []\n  }\n\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  return [String(value)]\n}\n\n/**\n * Gets all the values for the given keys in the given item and returns an array of those values\n * @param item - the item from which the values will be retrieved\n * @param keys - the keys to use to retrieve the values\n * @return objects with {itemValue, attributes}\n */\nfunction getAllValuesToRank<TItem>(\n  item: TItem,\n  accessors: ReadonlyArray<Accessor<TItem>>\n) {\n  const allValues: Array<{\n    itemValue: string\n    attributes: AccessorAttributes\n  }> = []\n  for (let j = 0, J = accessors.length; j < J; j++) {\n    const accessor = accessors[j]!\n    const attributes = getAccessorAttributes(accessor)\n    const itemValues = getItemValues(item, accessor)\n    for (let i = 0, I = itemValues.length; i < I; i++) {\n      allValues.push({\n        itemValue: itemValues[i]!,\n        attributes,\n      })\n    }\n  }\n  return allValues\n}\n\nconst defaultKeyAttributes = {\n  maxRanking: Infinity as Ranking,\n  minRanking: -Infinity as Ranking,\n}\n/**\n * Gets all the attributes for the given accessor\n * @param accessor - the accessor from which the attributes will be retrieved\n * @return object containing the accessor's attributes\n */\nfunction getAccessorAttributes<TItem>(\n  accessor: Accessor<TItem>\n): AccessorAttributes {\n  if (typeof accessor === 'function') {\n    return defaultKeyAttributes\n  }\n  return { ...defaultKeyAttributes, ...accessor }\n}\n", "/* istanbul ignore file */\n\nimport type { Query } from '@tanstack/query-core'\n\ntype SortFn = (a: Query, b: Query) => number\n\n// eslint-disable-next-line no-shadow\nenum QueryState {\n  Fetching = 0,\n  Fresh,\n  Stale,\n  Inactive,\n  Paused,\n}\n\nexport function getQueryState(query: Query): QueryState {\n  if (query.state.fetchStatus === 'fetching') {\n    return QueryState.Fetching\n  }\n  if (query.state.fetchStatus === 'paused') {\n    return QueryState.Paused\n  }\n  if (!query.getObserversCount()) {\n    return QueryState.Inactive\n  }\n  if (query.isStale()) {\n    return QueryState.Stale\n  }\n\n  return QueryState.Fresh\n}\n\nexport function getQueryStateLabel(query: Query): string {\n  const queryState = getQueryState(query)\n\n  if (queryState === QueryState.Fetching) {\n    return 'fetching'\n  }\n  if (queryState === QueryState.Paused) {\n    return 'paused'\n  }\n  if (queryState === QueryState.Stale) {\n    return 'stale'\n  }\n  if (queryState === QueryState.Inactive) {\n    return 'inactive'\n  }\n\n  return 'fresh'\n}\n\nexport function getQueryStatusFg(query: Query): number {\n  const queryState = getQueryState(query)\n\n  if (queryState === QueryState.Stale) {\n    return 0x000000\n  }\n\n  return 0xffffff\n}\n\nexport function getQueryStatusBg(query: Query): number {\n  const queryState = getQueryState(query)\n\n  if (queryState === QueryState.Fetching) {\n    return 0x006bff\n  }\n  if (queryState === QueryState.Paused) {\n    return 0x8c49eb\n  }\n  if (queryState === QueryState.Stale) {\n    return 0xffb200\n  }\n  if (queryState === QueryState.Inactive) {\n    return 0x3f4e60\n  }\n\n  return 0x008327\n}\n\nconst queryHashSort: SortFn = (a, b) => a.queryHash.localeCompare(b.queryHash)\n\nconst dateSort: SortFn = (a, b) =>\n  a.state.dataUpdatedAt < b.state.dataUpdatedAt ? 1 : -1\n\nconst statusAndDateSort: SortFn = (a, b) => {\n  if (getQueryState(a) === getQueryState(b)) {\n    return dateSort(a, b)\n  }\n\n  return getQueryState(a) > getQueryState(b) ? 1 : -1\n}\n\nexport const sortFns: Record<string, SortFn> = {\n  'Status > Last Updated': statusAndDateSort,\n  'Query Hash': queryHashSort,\n  'Last Updated': dateSort,\n}\n", "/* istanbul ignore file */\n\nimport { setupDevtoolsPlugin } from '@vue/devtools-api'\nimport type { CustomInspectorNode } from '@vue/devtools-api'\nimport { rankItem } from '@tanstack/match-sorter-utils'\nimport type { Query } from '@tanstack/query-core'\nimport type { QueryClient } from '../queryClient'\nimport {\n  getQueryStateLabel,\n  getQueryStatusBg,\n  getQueryStatusFg,\n  sortFns,\n} from './utils'\n\nconst pluginId = 'vue-query'\nconst pluginName = 'Vue Query'\n\nexport function setupDevtools(app: any, queryClient: QueryClient) {\n  setupDevtoolsPlugin(\n    {\n      id: pluginId,\n      label: pluginName,\n      packageName: 'vue-query',\n      homepage: 'https://github.com/DamianOsipiuk/vue-query',\n      logo: 'https://vue-query.vercel.app/vue-query.svg',\n      app,\n      settings: {\n        baseSort: {\n          type: 'choice',\n          component: 'button-group',\n          label: 'Sort Cache Entries',\n          options: [\n            {\n              label: 'ASC',\n              value: 1,\n            },\n            {\n              label: 'DESC',\n              value: -1,\n            },\n          ],\n          defaultValue: 1,\n        },\n        sortFn: {\n          type: 'choice',\n          label: 'Sort Function',\n          options: Object.keys(sortFns).map((key) => ({\n            label: key,\n            value: key,\n          })),\n          defaultValue: Object.keys(sortFns)[0]!,\n        },\n      },\n    },\n    (api) => {\n      const queryCache = queryClient.getQueryCache()\n\n      api.addInspector({\n        id: pluginId,\n        label: pluginName,\n        icon: 'api',\n        nodeActions: [\n          {\n            icon: 'cloud_download',\n            tooltip: 'Refetch',\n            action: (queryHash: string) => {\n              queryCache.get(queryHash)?.fetch()\n            },\n          },\n          {\n            icon: 'alarm',\n            tooltip: 'Invalidate',\n            action: (queryHash: string) => {\n              const query = queryCache.get(queryHash) as Query\n              queryClient.invalidateQueries(query.queryKey)\n            },\n          },\n          {\n            icon: 'settings_backup_restore',\n            tooltip: 'Reset',\n            action: (queryHash: string) => {\n              queryCache.get(queryHash)?.reset()\n            },\n          },\n          {\n            icon: 'delete',\n            tooltip: 'Remove',\n            action: (queryHash: string) => {\n              const query = queryCache.get(queryHash) as Query\n              queryCache.remove(query)\n            },\n          },\n        ],\n      })\n\n      api.addTimelineLayer({\n        id: pluginId,\n        label: pluginName,\n        color: 0xffd94c,\n      })\n\n      queryCache.subscribe((event) => {\n        api.sendInspectorTree(pluginId)\n        api.sendInspectorState(pluginId)\n\n        if (\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          event &&\n          ['queryAdded', 'queryRemoved', 'queryUpdated'].includes(event.type)\n        ) {\n          api.addTimelineEvent({\n            layerId: pluginId,\n            event: {\n              title: event.type,\n              subtitle: event.query.queryHash,\n              time: api.now(),\n              data: {\n                queryHash: event.query.queryHash,\n                ...event,\n              },\n            },\n          })\n        }\n      })\n\n      api.on.getInspectorTree((payload) => {\n        if (payload.inspectorId === pluginId) {\n          const queries = queryCache.getAll()\n          const settings = api.getSettings()\n\n          const filtered = payload.filter\n            ? queries.filter(\n                (item) => rankItem(item.queryHash, payload.filter).passed,\n              )\n            : [...queries]\n\n          const sorted = filtered.sort(\n            (a, b) => sortFns[settings.sortFn]!(a, b) * settings.baseSort,\n          )\n\n          const nodes: CustomInspectorNode[] = sorted.map((query) => {\n            const stateLabel = getQueryStateLabel(query)\n\n            return {\n              id: query.queryHash,\n              label: query.queryHash,\n              tags: [\n                {\n                  label: `${stateLabel} [${query.getObserversCount()}]`,\n                  textColor: getQueryStatusFg(query),\n                  backgroundColor: getQueryStatusBg(query),\n                },\n              ],\n            }\n          })\n          payload.rootNodes = nodes\n        }\n      })\n\n      api.on.getInspectorState((payload) => {\n        if (payload.inspectorId === pluginId) {\n          const query = queryCache.get(payload.nodeId)\n\n          if (!query) {\n            return\n          }\n\n          payload.state = {\n            ' Query Details': [\n              {\n                key: 'Query key',\n                value: query.queryHash as string,\n              },\n              {\n                key: 'Query status',\n                value: getQueryStateLabel(query),\n              },\n              {\n                key: 'Observers',\n                value: query.getObserversCount(),\n              },\n              {\n                key: 'Last Updated',\n                value: new Date(query.state.dataUpdatedAt).toLocaleTimeString(),\n              },\n            ],\n            'Data Explorer': [\n              {\n                key: 'Data',\n                value: query.state.data,\n              },\n            ],\n            'Query Explorer': [\n              {\n                key: 'Query',\n                value: query,\n              },\n            ],\n          }\n        }\n      })\n    },\n  )\n}\n", "import { isVue2 } from 'vue-demi'\nimport type { QueryClientConfig } from '@tanstack/query-core'\n\nimport { QueryClient } from './queryClient'\nimport { getClientKey } from './utils'\nimport { setupDevtools } from './devtools/devtools'\nimport type { MaybeRefDeep } from './types'\n\ndeclare global {\n  interface Window {\n    __VUE_QUERY_CONTEXT__?: QueryClient\n  }\n}\n\nexport interface AdditionalClient {\n  queryClient: QueryClient\n  queryClientKey: string\n}\n\ninterface ConfigOptions {\n  queryClientConfig?: MaybeRefDeep<QueryClientConfig>\n  queryClientKey?: string\n  contextSharing?: boolean\n}\n\ninterface ClientOptions {\n  queryClient?: QueryClient\n  queryClientKey?: string\n  contextSharing?: boolean\n}\n\nexport type VueQueryPluginOptions = ConfigOptions | ClientOptions\n\nexport const VueQueryPlugin = {\n  install: (app: any, options: VueQueryPluginOptions = {}) => {\n    const clientKey = getClientKey(options.queryClientKey)\n    let client: QueryClient\n\n    if ('queryClient' in options && options.queryClient) {\n      client = options.queryClient\n    } else {\n      if (options.contextSharing && typeof window !== 'undefined') {\n        if (!window.__VUE_QUERY_CONTEXT__) {\n          const clientConfig =\n            'queryClientConfig' in options\n              ? options.queryClientConfig\n              : undefined\n          client = new QueryClient(clientConfig)\n          window.__VUE_QUERY_CONTEXT__ = client\n        } else {\n          client = window.__VUE_QUERY_CONTEXT__\n        }\n      } else {\n        const clientConfig =\n          'queryClientConfig' in options ? options.queryClientConfig : undefined\n        client = new QueryClient(clientConfig)\n      }\n    }\n\n    client.mount()\n\n    const cleanup = () => {\n      client.unmount()\n    }\n\n    if (app.onUnmount) {\n      app.onUnmount(cleanup)\n    } else {\n      const originalUnmount = app.unmount\n      app.unmount = function vueQueryUnmount() {\n        cleanup()\n        originalUnmount()\n      }\n    }\n\n    /* istanbul ignore next */\n    if (isVue2) {\n      app.mixin({\n        beforeCreate() {\n          // HACK: taken from provide(): https://github.com/vuejs/composition-api/blob/master/src/apis/inject.ts#L30\n          if (!this._provided) {\n            const provideCache = {}\n            Object.defineProperty(this, '_provided', {\n              get: () => provideCache,\n              set: (v) => Object.assign(provideCache, v),\n            })\n          }\n\n          this._provided[clientKey] = client\n\n          if (process.env.NODE_ENV === 'development') {\n            if (this === this.$root) {\n              setupDevtools(this, client)\n            }\n          }\n        },\n      })\n    } else {\n      app.provide(clientKey, client)\n\n      if (process.env.NODE_ENV === 'development') {\n        setupDevtools(app, client)\n      }\n    }\n  },\n}\n", "import { onScopeDispose, toRefs, readonly, reactive, watch } from 'vue-demi'\nimport type { ToRefs, UnwrapRef } from 'vue-demi'\nimport type {\n  QueryObserver,\n  QueryKey,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryFunction,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './useQueryClient'\nimport { updateState, isQueryKey, cloneDeepUnref } from './utils'\nimport type { WithQueryClientKey } from './types'\nimport type { UseQueryOptions } from './useQuery'\nimport type { UseInfiniteQueryOptions } from './useInfiniteQuery'\n\nexport type UseQueryReturnType<\n  TData,\n  TError,\n  Result = QueryObserverResult<TData, TError>,\n> = ToRefs<Readonly<Result>> & {\n  suspense: () => Promise<Result>\n}\n\ntype UseQueryOptionsGeneric<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  | UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  Observer: typeof QueryObserver,\n  arg1:\n    | TQueryKey\n    | UseQueryOptionsGeneric<TQueryFnData, TError, TData, TQueryKey>,\n  arg2:\n    | QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>\n    | UseQueryOptionsGeneric<TQueryFnData, TError, TData, TQueryKey> = {},\n  arg3: UseQueryOptionsGeneric<TQueryFnData, TError, TData, TQueryKey> = {},\n): UseQueryReturnType<TData, TError> {\n  const options = getQueryUnreffedOptions()\n  const queryClient =\n    options.queryClient ?? useQueryClient(options.queryClientKey)\n  const defaultedOptions = queryClient.defaultQueryOptions(options)\n  const observer = new Observer(queryClient, defaultedOptions)\n  const state = reactive(observer.getCurrentResult())\n  const unsubscribe = observer.subscribe((result) => {\n    updateState(state, result)\n  })\n\n  watch(\n    [() => arg1, () => arg2, () => arg3],\n    () => {\n      observer.setOptions(\n        queryClient.defaultQueryOptions(getQueryUnreffedOptions()),\n      )\n    },\n    { deep: true },\n  )\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  const suspense = () => {\n    return new Promise<QueryObserverResult<TData, TError>>((resolve) => {\n      const run = () => {\n        const newOptions = queryClient.defaultQueryOptions(\n          getQueryUnreffedOptions(),\n        )\n        if (newOptions.enabled !== false) {\n          const optimisticResult = observer.getOptimisticResult(newOptions)\n          if (optimisticResult.isStale) {\n            resolve(observer.fetchOptimistic(defaultedOptions))\n          } else {\n            resolve(optimisticResult)\n          }\n        }\n      }\n\n      run()\n\n      watch([() => arg1, () => arg2, () => arg3], run, { deep: true })\n    })\n  }\n\n  return {\n    ...(toRefs(readonly(state)) as UseQueryReturnType<TData, TError>),\n    suspense,\n  }\n\n  /**\n   * Get Query Options object\n   * All inner refs unwrapped. No Reactivity\n   */\n  function getQueryUnreffedOptions() {\n    let mergedOptions\n\n    if (!isQueryKey(arg1)) {\n      // `useQuery(optionsObj)`\n      mergedOptions = arg1\n    } else if (typeof arg2 === 'function') {\n      // `useQuery(queryKey, queryFn, optionsObj?)`\n      mergedOptions = { ...arg3, queryKey: arg1, queryFn: arg2 }\n    } else {\n      // `useQuery(queryKey, optionsObj?)`\n      mergedOptions = { ...arg2, queryKey: arg1 }\n    }\n\n    return cloneDeepUnref(mergedOptions) as WithQueryClientKey<\n      QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n    >\n  }\n}\n", "import type { ToRefs, UnwrapRef } from 'vue-demi'\nimport { QueryObserver } from '@tanstack/query-core'\nimport type {\n  QueryFunction,\n  QueryKey,\n  QueryObserverResult,\n  DefinedQueryObserverResult,\n} from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type { UseQueryReturnType as UQRT } from './useBaseQuery'\nimport type { WithQueryClientKey, VueQueryObserverOptions } from './types'\n\ntype UseQueryReturnType<TData, TError> = Omit<\n  UQRT<TData, TError>,\n  'refetch' | 'remove'\n> & {\n  refetch: QueryObserverResult<TData, TError>['refetch']\n  remove: QueryObserverResult<TData, TError>['remove']\n}\n\ntype UseQueryDefinedReturnType<TData, TError> = Omit<\n  ToRefs<Readonly<DefinedQueryObserverResult<TData, TError>>>,\n  'refetch' | 'remove'\n> & {\n  suspense: () => Promise<QueryObserverResult<TData, TError>>\n  refetch: QueryObserverResult<TData, TError>['refetch']\n  remove: QueryObserverResult<TData, TError>['remove']\n}\n\nexport type UseQueryOptions<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = WithQueryClientKey<\n  VueQueryObserverOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>\n>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): UseQueryDefinedReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): UseQueryDefinedReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey'\n  >,\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): UseQueryDefinedReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn'\n  >,\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg2?:\n    | QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>\n    | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg3?: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n):\n  | UseQueryReturnType<TData, TError>\n  | UseQueryDefinedReturnType<TData, TError> {\n  const result = useBaseQuery(QueryObserver, arg1, arg2, arg3)\n\n  return {\n    ...result,\n    refetch: result.refetch.value,\n    remove: result.remove.value,\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { QueriesObserver } from '@tanstack/query-core'\nimport { onScopeDispose, reactive, readonly, watch } from 'vue-demi'\nimport type { Ref } from 'vue-demi'\n\nimport type { QueryFunction, QueryObserverResult } from '@tanstack/query-core'\n\nimport { useQueryClient } from './useQueryClient'\nimport type { UseQueryOptions } from './useQuery'\nimport { cloneDeepUnref } from './utils'\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptions<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptions<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptions<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptions<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptions<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptions<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryOptions<TQueryFnData, unknown, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? UseQueryOptions<TQueryFnData, unknown, TQueryFnData, TQueryKey>\n    : // Fallback\n      UseQueryOptions\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? QueryObserverResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? QueryObserverResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? QueryObserverResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? QueryObserverResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? QueryObserverResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? QueryObserverResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? QueryObserverResult<TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? QueryObserverResult<TQueryFnData>\n    : // Fallback\n      QueryObserverResult\n\n/**\n * UseQueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type UseQueriesOptions<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryOptions[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? UseQueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends UseQueryOptions<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    UseQueryOptions[]\n\n/**\n * UseQueriesResults reducer recursively maps type param to results\n */\nexport type UseQueriesResults<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? QueryObserverResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? UseQueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends UseQueryOptions<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    QueryObserverResult<unknown extends TData ? TQueryFnData : TData, TError>[]\n  : // Fallback\n    QueryObserverResult[]\n\ntype UseQueriesOptionsArg<T extends any[]> = readonly [...UseQueriesOptions<T>]\n\nexport function useQueries<T extends any[]>({\n  queries,\n}: {\n  queries: Ref<UseQueriesOptionsArg<T>> | UseQueriesOptionsArg<T>\n}): Readonly<UseQueriesResults<T>> {\n  const unreffedQueries = cloneDeepUnref(queries) as UseQueriesOptionsArg<T>\n\n  const queryClientKey = unreffedQueries[0].queryClientKey\n  const optionsQueryClient = unreffedQueries[0].queryClient\n  const queryClient = optionsQueryClient ?? useQueryClient(queryClientKey)\n  const defaultedQueries = unreffedQueries.map((options) => {\n    return queryClient.defaultQueryOptions(options)\n  })\n\n  const observer = new QueriesObserver(queryClient, defaultedQueries)\n  const state = reactive(observer.getCurrentResult())\n\n  const unsubscribe = observer.subscribe((result) => {\n    state.splice(0, state.length, ...result)\n  })\n\n  watch(\n    () => queries,\n    () => {\n      const defaulted = (\n        cloneDeepUnref(queries) as UseQueriesOptionsArg<T>\n      ).map((options) => {\n        return queryClient.defaultQueryOptions(options)\n      })\n      observer.setQueries(defaulted)\n    },\n    { deep: true },\n  )\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return readonly(state) as UseQueriesResults<T>\n}\n", "import { InfiniteQueryObserver } from '@tanstack/query-core'\nimport type { UnwrapRef } from 'vue-demi'\nimport type {\n  QueryObserver,\n  QueryFunction,\n  QueryKey,\n  InfiniteQueryObserverResult,\n} from '@tanstack/query-core'\n\nimport { useBaseQuery } from './useBaseQuery'\nimport type { UseQueryReturnType } from './useBaseQuery'\n\nimport type {\n  WithQueryClientKey,\n  VueInfiniteQueryObserverOptions,\n} from './types'\n\nexport type UseInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = WithQueryClientKey<\n  VueInfiniteQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >\n>\n\ntype InfiniteQueryReturnType<TData, TError> = UseQueryReturnType<\n  TData,\n  TError,\n  InfiniteQueryObserverResult<TData, TError>\n>\ntype UseInfiniteQueryReturnType<TData, TError> = Omit<\n  InfiniteQueryReturnType<TData, TError>,\n  'fetchNextPage' | 'fetchPreviousPage' | 'refetch' | 'remove'\n> & {\n  fetchNextPage: InfiniteQueryObserverResult<TData, TError>['fetchNextPage']\n  fetchPreviousPage: InfiniteQueryObserverResult<\n    TData,\n    TError\n  >['fetchPreviousPage']\n  refetch: InfiniteQueryObserverResult<TData, TError>['refetch']\n  remove: InfiniteQueryObserverResult<TData, TError>['remove']\n}\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseInfiniteQueryReturnType<TData, TError>\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey'\n  >,\n): UseInfiniteQueryReturnType<TData, TError>\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>,\n  options?: Omit<\n    UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn'\n  >,\n): UseInfiniteQueryReturnType<TData, TError>\n\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1:\n    | TQueryKey\n    | UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg2?:\n    | QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>\n    | UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg3?: UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseInfiniteQueryReturnType<TData, TError> {\n  const result = useBaseQuery(\n    InfiniteQueryObserver as typeof QueryObserver,\n    arg1,\n    arg2,\n    arg3,\n  ) as InfiniteQueryReturnType<TData, TError>\n  return {\n    ...result,\n    fetchNextPage: result.fetchNextPage.value,\n    fetchPreviousPage: result.fetchPreviousPage.value,\n    refetch: result.refetch.value,\n    remove: result.remove.value,\n  }\n}\n", "import {\n  onScopeDispose,\n  reactive,\n  readonly,\n  toRefs,\n  watch,\n  computed,\n  isRef,\n} from 'vue-demi'\nimport type { ToRefs } from 'vue-demi'\nimport type {\n  MutateOptions,\n  MutationFunction,\n  MutationKey,\n  MutateFunction,\n  MutationObserverResult,\n  MutationObserverOptions,\n} from '@tanstack/query-core'\nimport type { WithQueryClientKey, MaybeRef, MaybeRefDeep } from './types'\nimport { MutationObserver } from '@tanstack/query-core'\nimport { cloneDeepUnref, updateState, isMutationKey } from './utils'\nimport { useQueryClient } from './useQueryClient'\n\ntype MutationResult<TData, TError, TVariables, TContext> = Omit<\n  MutationObserverResult<TData, TError, TVariables, TContext>,\n  'mutate' | 'reset'\n>\n\nexport type UseMutationOptions<TData, TError, TVariables, TContext> =\n  WithQueryClientKey<\n    MutationObserverOptions<TData, TError, TVariables, TContext>\n  >\n\nexport type VueMutationObserverOptions<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> = {\n  [Property in keyof UseMutationOptions<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >]: MaybeRefDeep<\n    UseMutationOptions<TData, TError, TVariables, TContext>[Property]\n  >\n}\n\ntype MutateSyncFunction<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> = (\n  ...options: Parameters<MutateFunction<TData, TError, TVariables, TContext>>\n) => void\n\nexport type UseMutationReturnType<\n  TData,\n  TError,\n  TVariables,\n  TContext,\n  Result = MutationResult<TData, TError, TVariables, TContext>,\n> = ToRefs<Readonly<Result>> & {\n  mutate: MutateSyncFunction<TData, TError, TVariables, TContext>\n  mutateAsync: MutateFunction<TData, TError, TVariables, TContext>\n  reset: MutationObserverResult<TData, TError, TVariables, TContext>['reset']\n}\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: MaybeRef<\n    VueMutationObserverOptions<TData, TError, TVariables, TContext>\n  >,\n): UseMutationReturnType<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationFn: MaybeRef<MutationFunction<TData, TVariables>>,\n  options?: MaybeRef<\n    Omit<\n      VueMutationObserverOptions<TData, TError, TVariables, TContext>,\n      'mutationFn'\n    >\n  >,\n): UseMutationReturnType<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MaybeRef<MutationKey>,\n  options?: MaybeRef<\n    Omit<\n      VueMutationObserverOptions<TData, TError, TVariables, TContext>,\n      'mutationKey'\n    >\n  >,\n): UseMutationReturnType<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MaybeRef<MutationKey>,\n  mutationFn?: MaybeRef<MutationFunction<TData, TVariables>>,\n  options?: MaybeRef<\n    Omit<\n      VueMutationObserverOptions<TData, TError, TVariables, TContext>,\n      'mutationKey' | 'mutationFn'\n    >\n  >,\n): UseMutationReturnType<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MaybeRef<MutationKey>\n    | MaybeRef<MutationFunction<TData, TVariables>>\n    | MaybeRef<VueMutationObserverOptions<TData, TError, TVariables, TContext>>,\n  arg2?:\n    | MaybeRef<MutationFunction<TData, TVariables>>\n    | MaybeRef<VueMutationObserverOptions<TData, TError, TVariables, TContext>>,\n  arg3?: MaybeRef<\n    VueMutationObserverOptions<TData, TError, TVariables, TContext>\n  >,\n): UseMutationReturnType<TData, TError, TVariables, TContext> {\n  const options = computed(() => {\n    return parseMutationArgs(arg1, arg2, arg3)\n  })\n  const queryClient =\n    options.value.queryClient ?? useQueryClient(options.value.queryClientKey)\n  const observer = new MutationObserver(\n    queryClient,\n    queryClient.defaultMutationOptions(options.value),\n  )\n  const state = reactive(observer.getCurrentResult())\n\n  const unsubscribe = observer.subscribe((result) => {\n    updateState(state, result)\n  })\n\n  const mutate = (\n    variables: TVariables,\n    mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>,\n  ) => {\n    observer.mutate(variables, mutateOptions).catch(() => {\n      // This is intentional\n    })\n  }\n\n  watch(\n    options,\n    () => {\n      observer.setOptions(queryClient.defaultMutationOptions(options.value))\n    },\n    { deep: true },\n  )\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  const resultRefs = toRefs(readonly(state)) as unknown as ToRefs<\n    Readonly<MutationResult<TData, TError, TVariables, TContext>>\n  >\n\n  return {\n    ...resultRefs,\n    mutate,\n    mutateAsync: state.mutate,\n    reset: state.reset,\n  }\n}\n\nexport function parseMutationArgs<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MaybeRef<MutationKey>\n    | MaybeRef<MutationFunction<TData, TVariables>>\n    | MaybeRef<VueMutationObserverOptions<TData, TError, TVariables, TContext>>,\n  arg2?:\n    | MaybeRef<MutationFunction<TData, TVariables>>\n    | MaybeRef<VueMutationObserverOptions<TData, TError, TVariables, TContext>>,\n  arg3?: MaybeRef<\n    VueMutationObserverOptions<TData, TError, TVariables, TContext>\n  >,\n): WithQueryClientKey<\n  MutationObserverOptions<TData, TError, TVariables, TContext>\n> {\n  const plainArg1 = isRef(arg1) ? arg1.value : arg1\n  const plainArg2 = isRef(arg2) ? arg2.value : arg2\n  let options = plainArg1\n  if (isMutationKey(plainArg1)) {\n    if (typeof plainArg2 === 'function') {\n      const plainArg3 = isRef(arg3) ? arg3.value : arg3\n      options = { ...plainArg3, mutationKey: plainArg1, mutationFn: plainArg2 }\n    } else {\n      options = { ...plainArg2, mutationKey: plainArg1 }\n    }\n  }\n\n  if (typeof plainArg1 === 'function') {\n    options = { ...plainArg2, mutationFn: plainArg1 }\n  }\n\n  return cloneDeepUnref(options) as UseMutationOptions<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >\n}\n", "import { onScopeDispose, ref, watch } from 'vue-demi'\nimport type { Ref } from 'vue-demi'\nimport type { QueryKey, QueryFilters as QF } from '@tanstack/query-core'\n\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref, isQueryKey } from './utils'\nimport type { MaybeRefDeep, WithQueryClientKey } from './types'\n\nexport type QueryFilters = MaybeRefDeep<WithQueryClientKey<QF>>\n\nexport function useIsFetching(filters?: QueryFilters): Ref<number>\nexport function useIsFetching(\n  queryKey?: QueryKey,\n  filters?: QueryFilters,\n): Ref<number>\nexport function useIsFetching(\n  arg1?: QueryKey | QueryFilters,\n  arg2?: QueryFilters,\n): Ref<number> {\n  const filters = ref(parseFilterArgs(arg1, arg2))\n  const queryClient =\n    filters.value.queryClient ?? useQueryClient(filters.value.queryClientKey)\n\n  const isFetching = ref(queryClient.isFetching(filters))\n\n  const unsubscribe = queryClient.getQueryCache().subscribe(() => {\n    isFetching.value = queryClient.isFetching(filters)\n  })\n\n  watch(\n    [() => arg1, () => arg2],\n    () => {\n      filters.value = parseFilterArgs(arg1, arg2)\n      isFetching.value = queryClient.isFetching(filters)\n    },\n    { deep: true },\n  )\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return isFetching\n}\n\nexport function parseFilterArgs(\n  arg1?: QueryKey | QueryFilters,\n  arg2: QueryFilters = {},\n) {\n  let options: QueryFilters\n\n  if (isQueryKey(arg1)) {\n    options = { ...arg2, queryKey: arg1 }\n  } else {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    options = arg1 || {}\n  }\n\n  return cloneDeepUnref(options) as WithQueryClientKey<QF>\n}\n", "import { onScopeDispose, ref, watch } from 'vue-demi'\nimport type { Ref } from 'vue-demi'\nimport type { MutationKey, MutationFilters as MF } from '@tanstack/query-core'\n\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref, isQueryKey } from './utils'\nimport type { MaybeRefDeep, WithQueryClientKey } from './types'\n\nexport type MutationFilters = MaybeRefDeep<WithQueryClientKey<MF>>\n\nexport function useIsMutating(filters?: MutationFilters): Ref<number>\nexport function useIsMutating(\n  mutationKey?: MutationKey,\n  filters?: Omit<MutationFilters, 'mutationKey'>,\n): Ref<number>\nexport function useIsMutating(\n  arg1?: MutationKey | MutationFilters,\n  arg2?: Omit<MutationFilters, 'mutationKey'>,\n): Ref<number> {\n  const filters = ref(parseMutationFilterArgs(arg1, arg2))\n  const queryClient =\n    filters.value.queryClient ?? useQueryClient(filters.value.queryClientKey)\n\n  const isMutating = ref(queryClient.isMutating(filters))\n\n  const unsubscribe = queryClient.getMutationCache().subscribe(() => {\n    isMutating.value = queryClient.isMutating(filters)\n  })\n\n  watch(\n    [() => arg1, () => arg2],\n    () => {\n      filters.value = parseMutationFilterArgs(arg1, arg2)\n      isMutating.value = queryClient.isMutating(filters)\n    },\n    { deep: true },\n  )\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return isMutating\n}\n\nexport function parseMutationFilterArgs(\n  arg1?: MutationKey | MutationFilters,\n  arg2: MutationFilters = {},\n) {\n  let options: MutationFilters\n\n  if (isQueryKey(arg1)) {\n    options = { ...arg2, mutationKey: arg1 }\n  } else {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    options = arg1 || {}\n  }\n\n  return cloneDeepUnref(options) as WithQueryClientKey<MF>\n}\n"],
  "mappings": "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EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,SAAI;EACJC,SAAI;EACJC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,SAAI;EACJC,SAAI;EACJC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,SAAI;EACJC,SAAI;EACJC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,SAAI;EACJC,SAAI;EACJC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,SAAI;EACJC,SAAI;EACJC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,SAAI;EACJC,SAAI;EACJC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,SAAI;EACJC,SAAI;EACJC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,SAAI;EACJC,SAAI;EACJC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,SAAI;EACJC,SAAI;EACJC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,SAAI;EACJC,SAAI;EACJC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,SAAI;EACJC,SAAI;EACJC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,SAAI;EACJC,SAAI;EACJC,SAAI;EACJC,SAAI;EACJC,SAAI;EACJC,SAAI;EACJC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,SAAI;EACJC,SAAI;EACJC,cAAI;EACJC,cAAI;EACJC,cAAI;EACJC,cAAI;EACJC,SAAI;EACJC,SAAI;EACJC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,QAAG;EACHC,SAAI;EACJC,QAAG;EACHC,QAAG;EACHC,QAAG;EAC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",
  "names": ["Subscribable", "constructor", "listeners", "subscribe", "bind", "listener", "push", "onSubscribe", "filter", "x", "onUnsubscribe", "hasListeners", "length", "isServer", "window", "noop", "undefined", "functionalUpdate", "updater", "input", "isValidTimeout", "value", "Infinity", "difference", "array1", "array2", "filter", "x", "indexOf", "replaceAt", "array", "index", "copy", "slice", "timeUntilStale", "updatedAt", "staleTime", "Math", "max", "Date", "now", "parseQueryArgs", "arg1", "arg2", "arg3", "isQueryKey", "queryKey", "queryFn", "parseMutationArgs", "mutationKey", "mutationFn", "parseFilterArgs", "parseMutationFilterArgs", "matchQuery", "filters", "query", "type", "exact", "fetchStatus", "predicate", "stale", "queryHash", "hashQueryKeyByOptions", "options", "partialMatchKey", "isActive", "isStale", "state", "matchMutation", "mutation", "fetching", "hashQueryKey", "status", "hashFn", "queryKeyHashFn", "JSON", "stringify", "_", "val", "isPlainObject", "Object", "keys", "sort", "reduce", "result", "key", "a", "b", "partialDeepEqual", "some", "replaceEqualDeep", "isPlainArray", "aSize", "length", "bItems", "bSize", "equalItems", "i", "shallowEqualObjects", "Array", "isArray", "o", "hasObjectPrototype", "ctor", "constructor", "prot", "prototype", "hasOwnProperty", "toString", "call", "isError", "Error", "sleep", "timeout", "Promise", "resolve", "setTimeout", "scheduleMicrotask", "callback", "then", "getAbortController", "AbortController", "replaceData", "prevData", "data", "isDataEqual", "structuralSharing", "FocusManager", "Subscribable", "constructor", "setup", "onFocus", "isServer", "window", "addEventListener", "listener", "removeEventListener", "onSubscribe", "cleanup", "setEventListener", "onUnsubscribe", "hasListeners", "undefined", "focused", "setFocused", "listeners", "forEach", "isFocused", "document", "includes", "visibilityState", "focusManager", "OnlineManager", "Subscribable", "constructor", "setup", "onOnline", "isServer", "window", "addEventListener", "listener", "removeEventListener", "onSubscribe", "cleanup", "setEventListener", "onUnsubscribe", "hasListeners", "undefined", "online", "setOnline", "listeners", "forEach", "isOnline", "navigator", "onLine", "onlineManager", "defaultRetryDelay", "failureCount", "Math", "min", "canFetch", "networkMode", "onlineManager", "isOnline", "CancelledError", "constructor", "options", "revert", "silent", "isCancelledError", "value", "createRetryer", "config", "isRetryCancelled", "isResolved", "continueFn", "promiseResolve", "promiseReject", "promise", "Promise", "outerResolve", "outerReject", "cancel", "cancelOptions", "reject", "abort", "cancelRetry", "continueRetry", "shouldPause", "focusManager", "isFocused", "resolve", "onSuccess", "onError", "pause", "continueResolve", "onPause", "then", "undefined", "onContinue", "run", "promiseOrValue", "fn", "error", "catch", "retry", "retryDelay", "delay", "shouldRetry", "onFail", "sleep", "continue", "defaultLogger", "console", "createNotifyManager", "queue", "transactions", "notifyFn", "callback", "batchNotifyFn", "batch", "result", "flush", "schedule", "push", "scheduleMicrotask", "batchCalls", "args", "originalQueue", "length", "forEach", "setNotifyFunction", "fn", "setBatchNotifyFunction", "notifyManager", "Removable", "destroy", "clearGcTimeout", "scheduleGc", "isValidTimeout", "cacheTime", "gcTimeout", "setTimeout", "optionalRemove", "updateCacheTime", "newCacheTime", "Math", "max", "isServer", "Infinity", "clearTimeout", "undefined", "Query", "Removable", "constructor", "config", "abortSignalConsumed", "defaultOptions", "setOptions", "options", "observers", "cache", "logger", "defaultLogger", "queryKey", "queryHash", "initialState", "state", "getDefaultState", "meta", "updateCacheTime", "cacheTime", "optionalRemove", "length", "fetchStatus", "remove", "setData", "newData", "data", "replaceData", "dispatch", "type", "dataUpdatedAt", "updatedAt", "manual", "setState", "setStateOptions", "cancel", "promise", "retryer", "then", "noop", "catch", "Promise", "resolve", "destroy", "silent", "reset", "isActive", "some", "observer", "enabled", "isDisabled", "getObserversCount", "isStale", "isInvalidated", "getCurrentResult", "isStaleByTime", "staleTime", "timeUntilStale", "onFocus", "find", "x", "shouldFetchOnWindowFocus", "refetch", "cancelRefetch", "continue", "onOnline", "shouldFetchOnReconnect", "addObserver", "indexOf", "push", "clearGcTimeout", "notify", "query", "removeObserver", "filter", "revert", "cancelRetry", "scheduleGc", "invalidate", "fetch", "fetchOptions", "continueRetry", "queryFn", "Array", "isArray", "process", "error", "abortController", "getAbortController", "queryFnContext", "pageParam", "undefined", "addSignalProperty", "object", "Object", "defineProperty", "enumerable", "get", "signal", "fetchFn", "reject", "context", "behavior", "onFetch", "revertState", "fetchMeta", "onError", "isCancelledError", "isFetchingOptimistic", "createRetryer", "fn", "abort", "bind", "onSuccess", "Error", "onFail", "failureCount", "onPause", "onContinue", "retry", "retryDelay", "networkMode", "action", "reducer", "fetchFailureCount", "fetchFailureReason", "canFetch", "status", "dataUpdateCount", "Date", "now", "errorUpdateCount", "errorUpdatedAt", "notifyManager", "batch", "forEach", "onQueryUpdate", "initialData", "hasInitialData", "initialDataUpdatedAt", "hasData", "QueryCache", "Subscribable", "constructor", "config", "queries", "queriesMap", "build", "client", "options", "state", "queryKey", "queryHash", "hashQueryKeyByOptions", "query", "get", "Query", "cache", "logger", "getLogger", "defaultQueryOptions", "defaultOptions", "getQueryDefaults", "meta", "add", "push", "notify", "type", "remove", "queryInMap", "destroy", "filter", "x", "clear", "notifyManager", "batch", "forEach", "getAll", "find", "arg1", "arg2", "filters", "parseFilterArgs", "exact", "matchQuery", "findAll", "Object", "keys", "length", "event", "listeners", "listener", "onFocus", "onOnline", "Mutation", "Removable", "constructor", "config", "options", "defaultOptions", "mutationId", "mutationCache", "logger", "defaultLogger", "observers", "state", "getDefaultState", "meta", "updateCacheTime", "cacheTime", "scheduleGc", "setState", "dispatch", "type", "addObserver", "observer", "indexOf", "push", "clearGcTimeout", "notify", "mutation", "removeObserver", "filter", "x", "optionalRemove", "length", "status", "remove", "continue", "retryer", "promise", "execute", "executeMutation", "createRetryer", "fn", "mutationFn", "Promise", "reject", "variables", "onFail", "failureCount", "error", "onPause", "onContinue", "retry", "retryDelay", "networkMode", "restored", "onMutate", "context", "data", "onSuccess", "onSettled", "onError", "process", "undefined", "action", "reducer", "failureReason", "isPaused", "canFetch", "notifyManager", "batch", "forEach", "onMutationUpdate", "MutationCache", "Subscribable", "constructor", "config", "mutations", "mutationId", "build", "client", "options", "state", "mutation", "Mutation", "mutationCache", "logger", "getLogger", "defaultMutationOptions", "defaultOptions", "mutationKey", "getMutationDefaults", "undefined", "meta", "add", "push", "notify", "type", "remove", "filter", "x", "clear", "notifyManager", "batch", "forEach", "getAll", "find", "filters", "exact", "matchMutation", "findAll", "event", "listeners", "listener", "resumePausedMutations", "pausedMutations", "isPaused", "reduce", "promise", "then", "continue", "catch", "noop", "Promise", "resolve", "infiniteQueryBehavior", "onFetch", "context", "fetchFn", "refetchPage", "fetchOptions", "meta", "fetchMore", "pageParam", "isFetchingNextPage", "direction", "isFetchingPreviousPage", "oldPages", "state", "data", "pages", "oldPageParams", "pageParams", "newPageParams", "cancelled", "addSignalProperty", "object", "Object", "defineProperty", "enumerable", "get", "signal", "aborted", "addEventListener", "queryFn", "options", "Promise", "reject", "buildNewPages", "param", "page", "previous", "fetchPage", "manual", "length", "resolve", "queryFnContext", "queryKey", "queryFnResult", "promise", "then", "getNextPageParam", "getPreviousPageParam", "shouldFetchFirstPage", "i", "shouldFetchNextPage", "finalPromise", "hasNextPage", "Array", "isArray", "nextPageParam", "hasPreviousPage", "previousPageParam", "QueryClient", "constructor", "config", "queryCache", "QueryCache", "mutationCache", "MutationCache", "logger", "defaultLogger", "defaultOptions", "queryDefaults", "mutationDefaults", "mount", "unsubscribeFocus", "focusManager", "subscribe", "isFocused", "resumePausedMutations", "onFocus", "unsubscribeOnline", "onlineManager", "isOnline", "onOnline", "unmount", "isFetching", "arg1", "arg2", "filters", "parseFilterArgs", "fetchStatus", "findAll", "length", "isMutating", "fetching", "getQueryData", "queryKey", "find", "state", "data", "getQueriesData", "queryKeyOrFilters", "getQueryCache", "map", "setQueryData", "updater", "options", "query", "prevData", "functionalUpdate", "undefined", "parsedOptions", "parseQueryArgs", "defaultedOptions", "defaultQueryOptions", "build", "setData", "manual", "setQueriesData", "notifyManager", "batch", "getQueryState", "removeQueries", "forEach", "remove", "resetQueries", "arg3", "refetchFilters", "type", "reset", "refetchQueries", "cancelQueries", "cancelOptions", "revert", "promises", "cancel", "Promise", "all", "then", "noop", "catch", "invalidateQueries", "invalidate", "refetchType", "resolve", "filter", "isDisabled", "fetch", "cancelRefetch", "meta", "refetchPage", "promise", "throwOnError", "fetchQuery", "retry", "isStaleByTime", "staleTime", "prefetchQuery", "fetchInfiniteQuery", "behavior", "infiniteQueryBehavior", "prefetchInfiniteQuery", "getMutationCache", "getLogger", "getDefaultOptions", "setDefaultOptions", "setQueryDefaults", "result", "x", "hashQueryKey", "push", "getQueryDefaults", "firstMatchingDefaults", "partialMatchKey", "process", "matchingDefaults", "error", "JSON", "stringify", "setMutationDefaults", "mutationKey", "getMutationDefaults", "_defaulted", "queries", "queryHash", "hashQueryKeyByOptions", "refetchOnReconnect", "networkMode", "useErrorBoundary", "suspense", "defaultMutationOptions", "mutations", "clear", "QueryObserver", "Subscribable", "constructor", "client", "options", "trackedProps", "Set", "selectError", "bindMethods", "setOptions", "remove", "bind", "refetch", "onSubscribe", "listeners", "length", "currentQuery", "addObserver", "shouldFetchOnMount", "executeFetch", "updateTimers", "onUnsubscribe", "destroy", "shouldFetchOnReconnect", "shouldFetchOn", "refetchOnReconnect", "shouldFetchOnWindowFocus", "refetchOnWindowFocus", "clearStaleTimeout", "clearRefetchInterval", "removeObserver", "notifyOptions", "prevOptions", "prevQuery", "defaultQueryOptions", "shallowEqualObjects", "getQueryCache", "notify", "type", "query", "observer", "enabled", "Error", "queryKey", "updateQuery", "mounted", "hasListeners", "shouldFetchOptionally", "updateResult", "staleTime", "updateStaleTimeout", "nextRefetchInterval", "computeRefetchInterval", "currentRefetchInterval", "updateRefetchInterval", "getOptimisticResult", "build", "createResult", "getCurrentResult", "currentResult", "trackResult", "result", "trackedResult", "Object", "keys", "forEach", "key", "defineProperty", "configurable", "enumerable", "get", "add", "getCurrentQuery", "refetchPage", "fetch", "meta", "fetchOptimistic", "defaultedOptions", "isFetchingOptimistic", "then", "fetchOptions", "cancelRefetch", "promise", "throwOnError", "catch", "noop", "isServer", "isStale", "isValidTimeout", "time", "timeUntilStale", "dataUpdatedAt", "timeout", "staleTimeoutId", "setTimeout", "refetchInterval", "data", "nextInterval", "refetchIntervalId", "setInterval", "refetchIntervalInBackground", "focusManager", "isFocused", "clearTimeout", "undefined", "clearInterval", "prevResult", "prevResultState", "currentResultState", "prevResultOptions", "currentResultOptions", "queryChange", "queryInitialState", "state", "currentQueryInitialState", "prevQueryResult", "previousQueryResult", "error", "errorUpdatedAt", "fetchStatus", "status", "isPreviousData", "isPlaceholderData", "_optimisticResults", "fetchOnMount", "fetchOptionally", "canFetch", "networkMode", "keepPreviousData", "dataUpdateCount", "isSuccess", "select", "selectFn", "selectResult", "replaceData", "process", "getLogger", "placeholderData", "Date", "now", "isFetching", "isLoading", "isError", "isInitialLoading", "failureCount", "fetchFailureCount", "failureReason", "fetchFailureReason", "errorUpdateCount", "isFetched", "isFetchedAfterMount", "isRefetching", "isLoadingError", "isPaused", "isRefetchError", "nextResult", "defaultNotifyOptions", "cache", "shouldNotifyListeners", "notifyOnChangeProps", "size", "includedProps", "useErrorBoundary", "some", "typedKey", "changed", "has", "onQueryUpdate", "action", "onSuccess", "manual", "isCancelledError", "onError", "notifyManager", "batch", "onSettled", "listener", "shouldLoadOnMount", "retryOnMount", "refetchOnMount", "field", "value", "suspense", "isStaleByTime", "QueriesObserver", "Subscribable", "constructor", "client", "queries", "result", "observers", "observersMap", "setQueries", "onSubscribe", "listeners", "length", "forEach", "observer", "subscribe", "onUpdate", "onUnsubscribe", "destroy", "notifyOptions", "notifyManager", "batch", "prevObservers", "newObserverMatches", "findMatchingObservers", "match", "setOptions", "defaultedQueryOptions", "newObservers", "map", "newObserversMap", "Object", "fromEntries", "options", "queryHash", "newResult", "getCurrentResult", "hasIndexChange", "some", "index", "hasListeners", "difference", "notify", "getQueries", "getCurrentQuery", "getOptimisticResult", "defaultQueryOptions", "matchingObservers", "flatMap", "defaultedOptions", "find", "matchedQueryHashes", "unmatchedQueries", "filter", "includes", "unmatchedObservers", "prevObserver", "getObserver", "currentObserver", "QueryObserver", "newOrReusedObservers", "keepPreviousData", "previouslyUsedObserver", "undefined", "sortMatchesByOrderOfQueries", "a", "b", "indexOf", "concat", "sort", "replaceAt", "listener", "InfiniteQueryObserver", "QueryObserver", "constructor", "client", "options", "bindMethods", "fetchNextPage", "bind", "fetchPreviousPage", "setOptions", "notifyOptions", "behavior", "infiniteQueryBehavior", "getOptimisticResult", "pageParam", "fetch", "meta", "fetchMore", "direction", "createResult", "query", "state", "result", "hasNextPage", "data", "pages", "hasPreviousPage", "isFetchingNextPage", "fetchStatus", "fetchMeta", "isFetchingPreviousPage", "MutationObserver", "Subscribable", "constructor", "client", "options", "setOptions", "bindMethods", "updateResult", "mutate", "bind", "reset", "prevOptions", "defaultMutationOptions", "shallowEqualObjects", "getMutationCache", "notify", "type", "mutation", "currentMutation", "observer", "onUnsubscribe", "listeners", "length", "removeObserver", "onMutationUpdate", "action", "notifyOptions", "onSuccess", "onError", "getCurrentResult", "currentResult", "undefined", "variables", "mutateOptions", "build", "addObserver", "execute", "state", "getDefaultState", "result", "isLoading", "status", "isSuccess", "isError", "isIdle", "notifyManager", "batch", "data", "context", "onSettled", "error", "forEach", "listener", "dehydrateMutation", "mutation", "mutationKey", "options", "state", "dehydrateQuery", "query", "queryKey", "queryHash", "defaultShouldDehydrateMutation", "isPaused", "defaultShouldDehydrateQuery", "status", "dehydrate", "client", "mutations", "queries", "dehydrateMutations", "shouldDehydrateMutation", "getMutationCache", "getAll", "forEach", "push", "dehydrateQueries", "shouldDehydrateQuery", "getQueryCache", "hydrate", "dehydratedState", "mutationCache", "queryCache", "dehydratedMutation", "build", "defaultOptions", "dehydratedQuery", "get", "dataUpdatedAt", "setState", "VUE_QUERY_CLIENT", "getClientKey", "key", "suffix", "isQueryKey", "value", "Array", "isArray", "isMutationKey", "updateState", "state", "update", "Object", "keys", "forEach", "cloneDeep", "customizer", "result", "undefined", "isRef", "map", "val", "isPlainObject", "entries", "fromEntries", "cloneDeepUnref", "obj", "unref", "prototype", "toString", "call", "getPrototypeOf", "useQueryClient", "id", "vm", "getCurrentInstance", "proxy", "Error", "key", "getClientKey", "queryClient", "inject", "QueryCache", "QC", "find", "arg1", "arg2", "arg1Unreffed", "cloneDeepUnref", "arg2Unreffed", "findAll", "isQueryKey", "MutationCache", "MC", "find", "filters", "cloneDeepUnref", "findAll", "QueryClient", "QC", "constructor", "config", "unreffedConfig", "cloneDeepUnref", "vueQueryConfig", "logger", "defaultOptions", "queryCache", "QueryCache", "mutationCache", "MutationCache", "isFetching", "arg1", "arg2", "arg1Unreffed", "arg2Unreffed", "isQueryKey", "isMutating", "filters", "getQueryData", "queryKey", "getQueriesData", "queryKeyOrFilters", "unreffed", "setQueryData", "updater", "options", "setQueriesData", "arg3Unreffed", "getQueryState", "removeQueries", "resetQueries", "arg3", "cancelQueries", "invalidateQueries", "refetchQueries", "fetchQuery", "prefetchQuery", "fetchInfiniteQuery", "prefetchInfiniteQuery", "setDefaultOptions", "setQueryDefaults", "getQueryDefaults", "setMutationDefaults", "mutationKey", "getMutationDefaults", "characterMap", "\u00C0", "\u00C1", "\u00C2", "\u00C3", "\u00C4", "\u00C5", "\u1EA4", "\u1EAE", "\u1EB2", "\u1EB4", "\u1EB6", "\u00C6", "\u1EA6", "\u1EB0", "\u0202", "\u00C7", "\u1E08", "\u00C8", "\u00C9", "\u00CA", "\u00CB", "\u1EBE", "\u1E16", "\u1EC0", "\u1E14", "\u1E1C", "\u0206", "\u00CC", "\u00CD", "\u00CE", "\u00CF", "\u1E2E", "\u020A", "\u00D0", "\u00D1", "\u00D2", "\u00D3", "\u00D4", "\u00D5", "\u00D6", "\u00D8", "\u1ED0", "\u1E4C", "\u1E52", "\u020E", "\u00D9", "\u00DA", "\u00DB", "\u00DC", "\u00DD", "\u00E0", "\u00E1", "\u00E2", "\u00E3", "\u00E4", "\u00E5", "\u1EA5", "\u1EAF", "\u1EB3", "\u1EB5", "\u1EB7", "\u00E6", "\u1EA7", "\u1EB1", "\u0203", "\u00E7", "\u1E09", "\u00E8", "\u00E9", "\u00EA", "\u00EB", "\u1EBF", "\u1E17", "\u1EC1", "\u1E15", "\u1E1D", "\u0207", "\u00EC", "\u00ED", "\u00EE", "\u00EF", "\u1E2F", "\u020B", "\u00F0", "\u00F1", "\u00F2", "\u00F3", "\u00F4", "\u00F5", "\u00F6", "\u00F8", "\u1ED1", "\u1E4D", "\u1E53", "\u020F", "\u00F9", "\u00FA", "\u00FB", "\u00FC", "\u00FD", "\u00FF", "\u0100", "\u0101", "\u0102", "\u0103", "\u0104", "\u0105", "\u0106", "\u0107", "\u0108", "\u0109", "\u010A", "\u010B", "\u010C", "\u010D", "C\u0306", "c\u0306", "\u010E", "\u010F", "\u0110", "\u0111", "\u0112", "\u0113", "\u0114", "\u0115", "\u0116", "\u0117", "\u0118", "\u0119", "\u011A", "\u011B", "\u011C", "\u01F4", "\u011D", "\u01F5", "\u011E", "\u011F", "\u0120", "\u0121", "\u0122", "\u0123", "\u0124", "\u0125", "\u0126", "\u0127", "\u1E2A", "\u1E2B", "\u0128", "\u0129", "\u012A", "\u012B", "\u012C", "\u012D", "\u012E", "\u012F", "\u0130", "\u0131", "\u0132", "\u0133", "\u0134", "\u0135", "\u0136", "\u0137", "\u1E30", "\u1E31", "K\u0306", "k\u0306", "\u0139", "\u013A", "\u013B", "\u013C", "\u013D", "\u013E", "\u013F", "\u0140", "\u0141", "\u0142", "\u1E3E", "\u1E3F", "M\u0306", "m\u0306", "\u0143", "\u0144", "\u0145", "\u0146", "\u0147", "\u0148", "\u0149", "N\u0306", "n\u0306", "\u014C", "\u014D", "\u014E", "\u014F", "\u0150", "\u0151", "\u0152", "\u0153", "P\u0306", "p\u0306", "\u0154", "\u0155", "\u0156", "\u0157", "\u0158", "\u0159", "R\u0306", "r\u0306", "\u0212", "\u0213", "\u015A", "\u015B", "\u015C", "\u015D", "\u015E", "\u0218", "\u0219", "\u015F", "\u0160", "\u0161", "\u0162", "\u0163", "\u021B", "\u021A", "\u0164", "\u0165", "\u0166", "\u0167", "T\u0306", "t\u0306", "\u0168", "\u0169", "\u016A", "\u016B", "\u016C", "\u016D", "\u016E", "\u016F", "\u0170", "\u0171", "\u0172", "\u0173", "\u0216", "\u0217", "V\u0306", "v\u0306", "\u0174", "\u0175", "\u1E82", "\u1E83", "X\u0306", "x\u0306", "\u0176", "\u0177", "\u0178", "Y\u0306", "y\u0306", "\u0179", "\u017A", "\u017B", "\u017C", "\u017D", "\u017E", "\u017F", "\u0192", "\u01A0", "\u01A1", "\u01AF", "\u01B0", "\u01CD", "\u01CE", "\u01CF", "\u01D0", "\u01D1", "\u01D2", "\u01D3", "\u01D4", "\u01D5", "\u01D6", "\u01D7", "\u01D8", "\u01D9", "\u01DA", "\u01DB", "\u01DC", "\u1EE8", "\u1EE9", "\u1E78", "\u1E79", "\u01FA", "\u01FB", "\u01FC", "\u01FD", "\u01FE", "\u01FF", "\u00DE", "\u00FE", "\u1E54", "\u1E55", "\u1E64", "\u1E65", "X\u0301", "x\u0301", "\u0403", "\u0453", "\u040C", "\u045C", "A\u030B", "a\u030B", "E\u030B", "e\u030B", "I\u030B", "i\u030B", "\u01F8", "\u01F9", "\u1ED2", "\u1ED3", "\u1E50", "\u1E51", "\u1EEA", "\u1EEB", "\u1E80", "\u1E81", "\u1EF2", "\u1EF3", "\u0200", "\u0201", "\u0204", "\u0205", "\u0208", "\u0209", "\u020C", "\u020D", "\u0210", "\u0211", "\u0214", "\u0215", "B\u030C", "b\u030C", "\u010C\u0323", "\u010D\u0323", "\u00CA\u030C", "\u00EA\u030C", "F\u030C", "f\u030C", "\u01E6", "\u01E7", "\u021E", "\u021F", "J\u030C", "\u01F0", "\u01E8", "\u01E9", "M\u030C", "m\u030C", "P\u030C", "p\u030C", "Q\u030C", "q\u030C", "\u0158\u0329", "\u0159\u0329", "\u1E66", "\u1E67", "V\u030C", "v\u030C", "W\u030C", "w\u030C", "X\u030C", "x\u030C", "Y\u030C", "y\u030C", "A\u0327", "a\u0327", "B\u0327", "b\u0327", "\u1E10", "\u1E11", "\u0228", "\u0229", "\u0190\u0327", "\u025B\u0327", "\u1E28", "\u1E29", "I\u0327", "i\u0327", "\u0197\u0327", "\u0268\u0327", "M\u0327", "m\u0327", "O\u0327", "o\u0327", "Q\u0327", "q\u0327", "U\u0327", "u\u0327", "X\u0327", "x\u0327", "Z\u0327", "z\u0327", "chars", "Object", "keys", "join", "allAccents", "RegExp", "removeAccents", "str", "replace", "match", "rankings", "CASE_SENSITIVE_EQUAL", "EQUAL", "STARTS_WITH", "WORD_STARTS_WITH", "CONTAINS", "ACRONYM", "MATCHES", "NO_MATCH", "rankItem", "item", "value", "options", "threshold", "accessors", "rank", "getMatchRanking", "rankedValue", "accessorIndex", "accessorThreshold", "passed", "valuesToRank", "getAllValuesToRank", "rankingInfo", "i", "length", "rankValue", "newRank", "itemValue", "minRanking", "maxRanking", "attributes", "Math", "min", "testString", "stringToRank", "prepareValueForComparison", "toLowerCase", "startsWith", "includes", "getAcronym", "getClosenessRanking", "string", "acronym", "wordsInString", "split", "forEach", "wordInString", "splitByHyphenWords", "splitByHyphenWord", "substr", "matchingInOrderCharCount", "charNumber", "findMatchingCharacter", "matchChar", "index", "j", "J", "stringChar", "getRanking", "spread", "spreadPercentage", "inOrderPercentage", "ranking", "firstIndex", "I", "found", "prepareValueForComparison", "value", "keepDiacritics", "removeAccents", "getItemValues", "item", "accessor", "accessorFn", "Array", "isArray", "String", "getAllValuesToRank", "accessors", "allValues", "j", "J", "length", "attributes", "getAccessorAttributes", "itemValues", "i", "I", "push", "itemValue", "defaultKeyAttributes", "maxRanking", "Infinity", "minRanking", "QueryState", "getQueryState", "query", "state", "fetchStatus", "Fetching", "Paused", "getObserversCount", "Inactive", "isStale", "Stale", "Fresh", "getQueryStateLabel", "queryState", "getQueryStatusFg", "getQueryStatusBg", "queryHashSort", "a", "b", "queryHash", "localeCompare", "dateSort", "dataUpdatedAt", "statusAndDateSort", "sortFns", "pluginId", "pluginName", "setupDevtools", "app", "queryClient", "setupDevtoolsPlugin", "id", "label", "packageName", "homepage", "logo", "settings", "baseSort", "type", "component", "options", "value", "defaultValue", "sortFn", "Object", "keys", "sortFns", "map", "key", "api", "queryCache", "getQueryCache", "addInspector", "icon", "nodeActions", "tooltip", "action", "queryHash", "get", "fetch", "query", "invalidateQueries", "queryKey", "reset", "remove", "addTimelineLayer", "color", "subscribe", "event", "sendInspectorTree", "sendInspectorState", "includes", "addTimelineEvent", "layerId", "title", "subtitle", "time", "now", "data", "on", "getInspectorTree", "payload", "inspectorId", "queries", "getAll", "getSettings", "filtered", "filter", "item", "rankItem", "passed", "sorted", "sort", "a", "b", "nodes", "stateLabel", "getQueryStateLabel", "tags", "getObserversCount", "textColor", "getQueryStatusFg", "backgroundColor", "getQueryStatusBg", "rootNodes", "getInspectorState", "nodeId", "state", "Date", "dataUpdatedAt", "toLocaleTimeString", "VueQueryPlugin", "install", "app", "options", "clientKey", "getClientKey", "queryClientKey", "client", "queryClient", "contextSharing", "window", "__VUE_QUERY_CONTEXT__", "clientConfig", "queryClientConfig", "undefined", "QueryClient", "mount", "cleanup", "unmount", "onUnmount", "originalUnmount", "vueQueryUnmount", "isVue2", "mixin", "beforeCreate", "_provided", "provideCache", "Object", "defineProperty", "get", "set", "v", "assign", "process", "$root", "setupDevtools", "provide", "useBaseQuery", "Observer", "arg1", "arg2", "arg3", "options", "getQueryUnreffedOptions", "queryClient", "useQueryClient", "queryClientKey", "defaultedOptions", "defaultQueryOptions", "observer", "state", "reactive", "getCurrentResult", "unsubscribe", "subscribe", "result", "updateState", "watch", "setOptions", "deep", "onScopeDispose", "suspense", "Promise", "resolve", "run", "newOptions", "enabled", "optimisticResult", "getOptimisticResult", "isStale", "fetchOptimistic", "toRefs", "readonly", "mergedOptions", "isQueryKey", "queryKey", "queryFn", "cloneDeepUnref", "useQuery", "arg1", "arg2", "arg3", "result", "useBaseQuery", "QueryObserver", "refetch", "value", "remove", "useQueries", "queries", "unreffedQueries", "cloneDeepUnref", "queryClientKey", "optionsQueryClient", "queryClient", "useQueryClient", "defaultedQueries", "map", "options", "defaultQueryOptions", "observer", "QueriesObserver", "state", "reactive", "getCurrentResult", "unsubscribe", "subscribe", "result", "splice", "length", "watch", "defaulted", "setQueries", "deep", "onScopeDispose", "readonly", "useInfiniteQuery", "arg1", "arg2", "arg3", "result", "useBaseQuery", "InfiniteQueryObserver", "fetchNextPage", "value", "fetchPreviousPage", "refetch", "remove", "useMutation", "arg1", "arg2", "arg3", "options", "computed", "parseMutationArgs", "queryClient", "value", "useQueryClient", "queryClientKey", "observer", "MutationObserver", "defaultMutationOptions", "state", "reactive", "getCurrentResult", "unsubscribe", "subscribe", "result", "updateState", "mutate", "variables", "mutateOptions", "catch", "watch", "setOptions", "deep", "onScopeDispose", "resultRefs", "toRefs", "readonly", "mutateAsync", "reset", "plainArg1", "isRef", "plainArg2", "isMutationKey", "plainArg3", "mutationKey", "mutationFn", "cloneDeepUnref", "useIsFetching", "arg1", "arg2", "filters", "ref", "parseFilterArgs", "queryClient", "value", "useQueryClient", "queryClientKey", "isFetching", "unsubscribe", "getQueryCache", "subscribe", "watch", "deep", "onScopeDispose", "options", "isQueryKey", "queryKey", "cloneDeepUnref", "useIsMutating", "arg1", "arg2", "filters", "ref", "parseMutationFilterArgs", "queryClient", "value", "useQueryClient", "queryClientKey", "isMutating", "unsubscribe", "getMutationCache", "subscribe", "watch", "deep", "onScopeDispose", "options", "isQueryKey", "mutationKey", "cloneDeepUnref"]
}
